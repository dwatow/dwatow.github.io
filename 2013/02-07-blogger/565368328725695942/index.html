<!DOCTYPE html>
<html lang="zh-cmn-Hans">
    <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=UA-106752702-1"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());
    gtag("config", "UA-106752702-1");
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <meta itemprop="name" content="Chris" />
  <meta
    itemprop="image"
    content="https://avatars1.githubusercontent.com/u/1825852?v=3&s=460"
  />
  <link rel="canonical" href="https://dwatow.github.io/2013/02-07-blogger/565368328725695942/"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link
    href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100;0,200;0,300;0,400;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap"
    rel="stylesheet"
  />
  <meta name="description" content="¶Code Complete II《軟體建構之道 2》#8 讀書心得與整理 原文連結: https:&#x2F;&#x2F;darkblack01.blogspot.com&#x2F;2013&#x2F;02&#x2F;code-complate-ii-28.html 移植時的最後更新日期: 2013-02-08T11:01:41.930+08:00 第八章 防禦性程式設計Defensive Programming開車有防衛駕駛，寫程式有防禦性程">
<meta property="og:type" content="article">
<meta property="og:title" content="Code Complete II《軟體建構之道 2》#8 讀書心得與整理">
<meta property="og:url" content="https://dwatow.github.io/2013/02-07-blogger/565368328725695942/index.html">
<meta property="og:site_name" content="《Chris 技術筆記》">
<meta property="og:description" content="¶Code Complete II《軟體建構之道 2》#8 讀書心得與整理 原文連結: https:&#x2F;&#x2F;darkblack01.blogspot.com&#x2F;2013&#x2F;02&#x2F;code-complate-ii-28.html 移植時的最後更新日期: 2013-02-08T11:01:41.930+08:00 第八章 防禦性程式設計Defensive Programming開車有防衛駕駛，寫程式有防禦性程">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2013-02-06T22:28:00.000Z">
<meta property="article:modified_time" content="2022-03-05T00:42:54.130Z">
<meta property="article:author" content="Chris">
<meta property="article:tag" content="Code Complete 2">
<meta name="twitter:card" content="summary">
  <title>
    Code Complete II《軟體建構之道 2》#8 讀書心得與整理 - 《Chris 技術筆記》
  </title>
  <meta
    name="viewport"
    content="width=device-width,minimum-scale=1,initial-scale=1"
  />
  <script
    defer
    src="https://cdn.bootcdn.net/ajax/libs/raphael/2.3.0/raphael.min.js"
  ></script>
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    
<script src="/js/facebooksdk.js"></script>

    <div class="Shell">
        <aside class='SideBar'>
    <canvas id="ixbg" width="100%" height="100%"></canvas>
    <section class='avatar' style="background-image: linear-gradient(to bottom, #1e5799 0%, #f8f8f8 100%)">
    </section>
    <div class='av-pic' style="background-image: url(/assets/head.svg)"></div>
    <section class='menu'>
        <div>《Chris 技術筆記》</div>
        
            <div>設計 × 研究 × 程式</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Lastest</li>
            </a>
          
            <a href="/archives/" class="Btn">
              <li>Posts</li>
            </a>
          
            <a href="/about/" class="Btn">
              <li>Works</li>
            </a>
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>
          
            <a href="/categories/前端新手村/" class="Btn">
              <li>Novice F2E</li>
            </a>
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/dwatow" target="_blank">
                    <i class="fab fa-sm fa-github-alt"></i>
                </a>
            
        
            
                <a href="https://www.facebook.com/dwatow" target="_blank">
                    <i class="fab fa-sm fa-facebook-f"></i>
                </a>
            
        
            
                <a href="https://www.linkedin.com/in/chris-wang-604469107" target="_blank">
                    <i class="fab fa-sm fa-linkedin-in"></i>
                </a>
            
        
    </section>
</aside>

        <div class="container">
            <div data-pager-shell>
                <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Code Complete II《軟體建構之道 2》#8 讀書心得與整理</h1>
    </header>
    <section>
    
  <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Code-Complete-II%E3%80%8A%E8%BB%9F%E9%AB%94%E5%BB%BA%E6%A7%8B%E4%B9%8B%E9%81%93-2%E3%80%8B-8-%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97%E8%88%87%E6%95%B4%E7%90%86"><span class="toc-text">Code Complete II《軟體建構之道 2》#8 讀書心得與整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">第八章 防禦性程式設計
Defensive Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.1 保護程式在無效輸入資料的破壞
Protecting Your Program from Invalid Inputs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.2 判斷提示
Assertions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">建立自己的Assertion機制
Building Your Own Assertion Mechanism</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">使用Assertions的方針
Guidelines for Using Assertions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.3 錯誤處理技巧
Error-Handling Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">比較強壯性與正確性
Robustness vs. Correctness</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">高層次設計的錯誤處理啟示
High-Level Design Implications of Error Processing</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.4 例外狀況
Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.5 （防火牆）隔離你的程式，避免錯誤造成損毀
Barricade Your Program to Contain the Damage Caused by Errors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">防火牆與判斷提示的關係
Relationship between Barricades and Assertions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.6 除錯輔助工具
Debugging Aids</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">不要在debug版程式直接套用release版程式的規範
Don’t Automatically Apply Production Constraints to the Development Version</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">儘早採用除錯輔助工具
Introduce Debugging Aids Early</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">使用自殺式程式設計（原意：攻擊式程式設計）
Use Offensive Programming</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">計畫性移除錯輔助工具
Plan to Remove Debugging Aids</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.7 決定實際實執行所採用的防禦性程式設計程式碼
Determining How Much Defensive Programming to Leave in Production Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8.8 防禦性程式設計的防禦狀態
Being Defensive About Defensive Programming</span></a></li></ol></li></ol></li></ol>
  </div>


    <h1 id="Code-Complete-II《軟體建構之道-2》-8-讀書心得與整理"><a class="header-anchor" href="#Code-Complete-II《軟體建構之道-2》-8-讀書心得與整理">¶</a>Code Complete II《軟體建構之道 2》#8 讀書心得與整理</h1>
<p>原文連結: <a target="_blank" rel="noopener" href="https://darkblack01.blogspot.com/2013/02/code-complate-ii-28.html">https://darkblack01.blogspot.com/2013/02/code-complate-ii-28.html</a><br>
移植時的最後更新日期: 2013-02-08T11:01:41.930+08:00</p>
<h2><span style="font-size: x-large;">第八章 防禦性程式設計<br />Defensive Programming</span></h2>開車有防衛駕駛，寫程式有防禦性程式設計<br /><br /><br /><h3><span style="font-size: large;">8.1 保護程式在無效輸入資料的破壞<br />Protecting Your Program from Invalid Inputs</span></h3><br />優秀的程式，無輪輸入什麼內容，都不會輸出垃圾。<br /><br />a. 檢查所有來自外部的常式的參數<br />b. 檢查所有來自其它常式的常式的參數→8.5<br />c. 決定如何處理錯誤的輸入→5.3<br /><br />最優秀的防禦性程式撰寫 <br /><ol><li>重複的設計</li><li>程式碼前先寫虛擬碼</li><li>程式碼前先寫測試案例</li><li>進行低層級設計視察</li></ol><br /><a name='more'></a><br /><br /><br /><br /><br /><h3><span style="font-size: large;">8.2 判斷提示<br />Assertions</span></h3><pre class="prettyprint"><code>assert(常式); &nbsp;//若常式為false，則程式崩潰、印出訊息。</code></pre>用來檢查假設 <br /><ol><li>是否滿足定義域和值域</li><li>檔案或資料流狀態是否開啟（或關閉）</li><li>檔案或資料流讀寫位置是否在開頭（或結尾）</li><li>檢查檔案或資料流權限（唯讀、唯寫、可讀寫）。</li><li>只能輸入的變數，經過一個常式是否有被改變</li><li>指標是否為null</li><li>陣列項目數量是否為特定數目</li><li>初始化的表格，變數是否都初始化了。</li><li>在常式內的容器，是否為空（或滿）</li><li>最佳化前後的常式，結果是否一致</li><li>....（更多更多的假設）</li></ol><br /><br /><h4>建立自己的Assertion機制<br />Building Your Own Assertion Mechanism</h4><br />標準的C++不提供文字訊息<br />所以，可以改寫成適合自己使用的ASSERT() <br /><pre class="prettyprint"><code>//C++ Example of a Assertion Macro<br />#define Assert( condition, message )\<br />&#123;\<br />  if ( !(condition) )\<br />  &#123;\<br />    LogError ("Assertion failed: ", #condition, message);\<br />    exit( EXIT_FAILURE );\<br />  &#125;\<br />&#125;</code></pre><h4>使用Assertions的方針<br />Guidelines for Using Assertions</h4><table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;" x:str=""> <colgroup><col style="mso-width-alt: 3552; mso-width-source: userset;"></col> <col style="mso-width-alt: 6944; mso-width-source: userset;"></col> <col style="mso-width-alt: 6240; mso-width-source: userset;"></col> </colgroup><tbody><tr>  <td class="xl22">　</td>  <td class="xl23" style="border-left: none;">處理錯誤的程式碼</td>  <td class="xl23" style="border-left: none;">Assert（判斷提示）</td> </tr><tr>  <td class="xl22" style="border-top: none;">處理什麼狀況</td>  <td class="xl23" style="border-left: none; border-top: none;">預期會發生</td>  <td class="xl23" style="border-left: none; border-top: none;">永遠不應發生</td> </tr><tr>  <td class="xl22" style="border-top: none;">檢查什麼</td>  <td class="xl23" style="border-left: none; border-top: none;">鮮少發生的非一般情況</td>  <td class="xl23" style="border-left: none; border-top: none;">永遠不應發生</td> </tr><tr>  <td class="xl22" style="border-top: none;">用來檢查</td>  <td class="xl23" style="border-left: none; border-top: none;">檢查錯誤的輸入資料</td>  <td class="xl23" style="border-left: none; border-top: none;">檢查程式碼中的bug</td> </tr></tbody></table>異常情況→用處理錯誤的程式碼→從容的做出反映<br />異常情況→用Assert()→重新編譯程式碼<br /><br /><b>Assert()中，不可以放置發佈版本會執行的程式碼。</b><br /><pre class="prettyprint"><code>//系統預設的code，assert本身並不會在release編譯時成為release版的程式內容<br />#ifdef _DEBUG<br />    ASSERT()<br />#endif</code></pre><b>用Assert()來驗證前置條件和後置條件</b><br /><br />檢查輸入 - 前置條件<br />檢查輸出 - 後置條件<br /><br />錯誤： <br /><ol><li>可靠的內部來源，檢查定義域外的值←用Assert(定義域)</li><li>外部來源，檢查錯誤格式←錯誤處理的程式碼</li></ol><b>對強壯的程式碼，應先使用Assert再處理錯誤</b><br /><br />常式通常會用 <br /><ol><li>Assert()</li><li>處理錯誤的程式碼</li></ol>通常不會兩個都用，但是若專案很大，人很多，時間很長，則建議兩個都用。<br />外部輸入 無法預測，也建議使用。<br /><br />debug版，兩者都有。<br />release版，剩下錯誤處理程式碼。  <br /><pre class="prettyprint"><code class="lang-vb">Visual Basic Example of Using Assertion to Document Preconditions and Postconditions<br />private Function Velocity ( _<br />    ByRef latitude As Single, _<br />    ByRef longitude  As Single, _<br />    ByRef elevation  As Single, _<br />) As Single<br /><br />' Preconditions'<br /><br />Debug.Assert( -90&lt;= latitude And latitude &lt;= 90 )<br />Debug.Assert( ...)<br />Debug.Assert( ...)<br />...<br />' Sanitize input data. Values should be within the ranges asserted above,'<br />' but if a value is not within its valid range, it will be changed to the closest legal value'<br />If  ( latitude &lt; -90 ) Then<br />     latitude = -90<br />ElseIf ( latitude &gt; 90 ) then<br />    latitude = 90<br />...<br /></code></pre><br /><br /><h3><span style="font-size: large;">8.3 錯誤處理技巧<br />Error-Handling Techniques</span></h3>Assert()可用來處理程式中永遠不該發生的錯誤。<br />那預期發生的錯誤呢？<br /><br /><b>1. 傳回中性的值</b><br />&nbsp; &nbsp; 若程式對於「呈現錯誤資料」的容許度很低，就別考慮這個方式了。<br /><br /><b>2. 以下一個有效值取代</b><br /><b>3. 以上一個有效值取代</b><br /><b>4. 以最接近的有效值取代</b><br /><br /><b>5. 將警告訊息記錄至檔案</b><br />&nbsp; &nbsp; 要考慮檔案的安全性、公開性的容許程度。<br /><br /><b>6. 回傳Error code</b><br />&nbsp; &nbsp; 「處理錯誤」和「反映錯誤」的副程式（或物件）區分清楚。<br />&nbsp; &nbsp; 低層級的程式碼：反映錯誤<br />&nbsp; &nbsp; 高層級的程式碼：處理錯誤<br /><br />&nbsp; &nbsp; 通知系統錯誤的（東西），會下列其中一種 <br /><ol><li>&nbsp; &nbsp; 設定狀態變數的值</li><li>&nbsp; &nbsp; 將狀態回傳，作為常式的回傳值</li><li>&nbsp; &nbsp; 用程式語言內嵌的例外處理</li></ol>這種情況之下，與「報告錯誤」的機制相比，「決定系統哪些部份要直接處理錯誤，哪些部份只是報告發生的錯誤」比較重要。<br /><br /><b>7. 呼叫錯誤處理常式或物件</b><br />&nbsp; &nbsp; 設計「集中處理錯誤」的常式或物件。<br />&nbsp; &nbsp; 不使用此方法，會是基於安全性的考量。<br /><br /><b>8. 顯示錯誤訊息</b><br />&nbsp; &nbsp; 處理錯誤的資源，將會在此方法減到最少。<br />&nbsp; &nbsp; 難以進行UI一致性和當地語系化。<br />&nbsp; &nbsp; 可能會受到「錯誤訊息探索」的方法攻擊系統。<br /><br /><b>9. 在常式內以最僅方法處理錯誤</b><br />&nbsp; &nbsp; 錯理錯誤的特定方式由程式設計人員決定。<br />&nbsp; &nbsp; 無法滿足「正確性」或「強壯性」的需求。<br />&nbsp; &nbsp; 四處都要寫入「使用者介面程式碼」<br /><br /><b>10. 關機</b><br />&nbsp; &nbsp; &nbsp; 對於特續開機會造成失控的風險，考慮關機是不錯的選擇。<br />（詳情可參考絕命終結站XDD）<br /><br /><h4>比較強壯性與正確性<br />Robustness vs. Correctness</h4><br />定義：<br />正確性(Correctness)：永遠不回傳不正確的結果<br />強壯性(Robustness)：永遠嘗試讓軟體能繼續操作<br /><br />考量：<br />人身安全相關軟體 &nbsp;正確性&gt;強壯性<br />消費性應用軟體 &nbsp; &nbsp;強壯性&gt;正確性<br /><br /><h4>高層次設計的錯誤處理啟示<br />High-Level Design Implications of Error Processing</h4><br />錯誤處理的方式，是由「架構上」和「高層次設計時」決定。<br />錯誤處理必須一致。錯誤務必處理，不可忽視。<br /><br />ex:<br />高階處理錯誤<br />低階報告錯誤（回傳Error code）<br /><br /><br /><h3><span style="font-size: large;">8.4 例外狀況<br />Exceptions</span></h3><br />例外狀況是一種特定的方法。<br /><br />常見語言支援情況<br /><table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;" x:str=""> <colgroup><col style="mso-width-alt: 4896; mso-width-source: userset;"></col> <col style="mso-width-alt: 6080; mso-width-source: userset;"></col> <col style="mso-width-alt: 11680; mso-width-source: userset;"></col> <col style="mso-width-alt: 5792; mso-width-source: userset;"></col> </colgroup><tbody><tr>  <td class="xl22">例外狀況屬性</td>  <td class="xl22" style="border-left: none;">C++</td>  <td class="xl22" style="border-left: none;">Java</td>  <td class="xl22" style="border-left: none;">Visual Basic</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">支援try-catch</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">支援try-catch-finally</td>  <td class="xl23" style="border-left: none; border-top: none;">無</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td> </tr><tr>  <td class="xl23" style="border-top: none;">可throw出什麼</td>  <td class="xl23" style="border-left: none; border-top: none;">Execption及其衍生物件。<br />物件指標、物件參照<br />資料型別（ex: char*, int)</td>  <td class="xl23" style="border-left: none; border-top: none;">Execption及其衍生物件</td>  <td class="xl23" style="border-left: none; border-top: none;">Execption及其衍生物件</td> </tr><tr>  <td class="xl23" style="border-top: none;">未攔截的例外狀況時的預設處理方式</td>  <td class="xl23" style="border-left: none; border-top: none;">呼叫std::unex   pected()<br />再預設呼叫std::terminate()<br />再預設呼叫abort()</td>  <td class="xl23" style="border-left: none; border-top: none;">終止執行緒。</td>  <td class="xl23" style="border-left: none; border-top: none;">終止程式</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">必須在類別介面中定義throw出的例外狀況</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td>  <td class="xl23" style="border-left: none; border-top: none;">是</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">必須在類別介面中定義catch到的例外狀況</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td>  <td class="xl23" style="border-left: none; border-top: none;">是</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td> </tr></tbody></table><br /><b>用例外狀況通知其程式</b><br />例外狀況最大的好處，就是它能以無法忽略的方式，表示錯誤條件<br /><b>只在需要在真的例外狀況拋出throw</b><br />例外狀況只有Exception的try-catch可以處理，別的程式語法是無法取代的，而作用和assert()一樣，不只是處理罕見發生的事件，也處理永遠不應該發生的事。<br /><b>請勿將例外狀況來推卸責任</b><br />如果子程式可以在local程式碼處理例外狀況，請不要在這樣的程式碼throw出Exception，請在這個local程式碼處理掉。<br /><b>非在建構和解構式中攔截例外狀況，否則請避免在同樣位置中產生例外狀況</b><br />在建構式中發生Exception，那麼解構式中會變得複雜許多，否則就會在尚未建構的物件中解構，讓程式出現問題。<br />而在建構式和解構式中的Exception也會變得很複雜。<br /><b>以正確的抽象層產生例外狀況</b><br />維護概念整體性<br /><b>在例外狀況訊息內包含造成例外狀況的所有資訊</b><br />足夠多的訊息可以幫助閱讀的人了解情況。<br /><b>避免空的catch區塊</b><br /><pre class="prettyprint"><code>Bad Java Example of Ignoring an Exception<br />try&#123;<br />    ...<br />    //lots of cods<br />    ...<br />&#125; catch( AnException exception) &#123;<br />    //程式執行到這，不會終止，會當作沒有這個例外而繼續執行。<br />    //可以的話寫個MessageBox或者記錄到檔案中也好。<br />    //空白的話讓co-work的程式設計不知道這是怎麼一回事<br />&#125;</code></pre><b>了解程式庫程式碼所產生的例外狀況</b><br />程式庫(.dll檔)的Exception務必要全盤了解。<br /><b>考慮建立集中的例外狀況報告程式</b><br />報告成文件或顯示訊息，請統一報告的格式。<br /><b>標準化專案例外狀況的使用</b><br /><ul><li>用Exctption類別裝例外狀況拋出的所有物件。增加使用不同程式碼之間的相容性。</li><li>for專案的個人化Exception</li><li>定義在特定的情況中，程式碼可用throw-catch語法處理。</li><li>定義在特定的情況中，程式碼可用throw一個不在local程式碼中處理的exception&nbsp;。</li><li>決定是否使用集中的例外狀況報告格式</li><li>定義在構建式與解構式中，是否存在例外狀況。</li></ul><b>考慮例外 狀況的替代方法</b><br /><ul><li>區域程式處理錯誤</li><li>使用error code傳播錯誤</li><li>錯誤記錄到檔案中</li><li>關閉系統</li><li>其它</li></ul><span style="color: #cc0000;">記住要將程式「設計成語言&nbsp;(programming into a language)」，而不要掉進了「用語言」設計程式(programming in a language)。</span><br /><br /><br /><h3><span style="font-size: large;">8.5 （防火牆）隔離你的程式，避免錯誤造成損毀<br />Barricade Your Program to Contain the Damage Caused by Errors</span></h3><br />概念：船構造的隔艙，讓船在進水時，可以隔離充滿水的船艙。<br /><br /><b>在輸入時間，將輸入資料轉換為正確的型別</b><br />建立「防火牆」讓資料轉態、檢查資料格式、檢查資料內容，直到正確，才進入運算。<br /><br /><h4>防火牆與判斷提示的關係<br />Relationship between Barricades and Assertions</h4>防火牆外的常式，使用錯誤處理（各種適合的方法），假設資料都不安全<br />防火牆內的常式，使用assert()。<br />防火牆內偵測到錯誤的資料，代表程式有錯，而不是資料有錯。<br /><br /><br /><h3><span style="font-size: large;">8.6 除錯輔助工具<br />Debugging Aids</span></h3><br /><h4>不要在debug版程式直接套用release版程式的規範<br />Don’t Automatically Apply Production Constraints to the Development Version</h4><table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;" x:str=""> <colgroup><col span="3"></col> </colgroup><tbody><tr>  <td style="height: 16.5pt; width: 54pt;" width="72"></td>  <td>release</td>  <td>debug</td> </tr><tr>  <td>速度</td>  <td>快</td>  <td>不一定要快</td> </tr><tr>  <td>資源</td>  <td>愈少愈好</td>  <td>盡量使用</td> </tr><tr>  <td>操作的安全性</td>  <td>必須要安全</td>  <td>可使用不安全的操作</td> </tr></tbody></table>最優先的考量：保持開發過程的流暢<br /><br /><h4>儘早採用除錯輔助工具<br />Introduce Debugging Aids Early</h4>遇到了十次相同的問題，第十一次之後受不了了，寫了一個除錯輔助工具之後，再也不會遇到這個問題，心情愉快、工作順利，程式碼都乖乖的呢。<br />為了節省時間，保持開發過程流暢，不影響心情。請儘早使用。<br /><br />通常會有三種情況，會取得除錯輔助工具<br /><ol><li>遇到了好幾次相同的問題。</li><li>初次寫除錯輔助程式</li><li>使用之前專案的除錯輔助工具</li></ol><h4>使用自殺式程式設計（原意：攻擊式程式設計）<br />Use Offensive Programming</h4>應該以這麼一種方式來處理異常情況：在開發階段將它突顯出來，在產品代碼時它可以自我修復。←就是Offensive Programming<br /><br />自殺式程式設計方法有幾個原則（看完就知道為什麼我這樣翻譯了）<br /><ul><li>確定以assert()中止程式</li><li>完全填滿記憶體，偵測記憶體配置問題</li><li>完全填滿分配的檔案，偵測出檔案格式的錯誤</li><li>確定每個「case陳述式的default」或「else子句」的程式碼能產生錯誤（ex: 中止程式）或無法被忽略。</li><li>刪除物件前，填入垃圾值，確定它再也用不到。</li><li>設定程式將錯誤記錄檔以mail的方式寄給自己，以了解release後的軟體中發生的錯誤種類。</li></ul><br /><h4>計畫性移除錯輔助工具<br />Plan to Remove Debugging Aids</h4>為了大小和速度必須拆除鷹架（除錯輔助程式碼）<br /><br /><b>使用版本工具，並建立<a href="http://ant.apache.org/" target="_blank">ant</a>和<a href="http://gnuwin32.sourceforge.net/packages/make.htm" target="_blank">make</a>等工具</b><br />ant 是java使用的工具，make就是makefile的工具。<br /><br /><b>使用內嵌的前置處理器</b><br />技巧性的使用條件編譯，可以留下鷹架，讓它不會編譯進release版<br />使用前置處理器的code，讓#ifdef-#endif這樣的程式碼不會讓你的程式變醜醜的。 <br /><pre class="prettyprint"><code>#define DEBUG<br />...<br />#if define( DEBUG )<br />// debugging code<br />...<br />#endif</code></pre><pre class="prettyprint"><code>#define DEBUG<br />#if define( DEBUG )<br />#define DebugCode( code_fragment ) &#123; code_fragment &#125;<br />#else<br />#define DebugCode( code_fragment )<br />#endif<br />...<br />DebugCode(<br /><br />    statement 1;<br />    statement 2;<br />    statement 3;<br /><br />);<br />...</code></pre><b>撰寫自己的前置處理器</b><br />Java沒有，就自己寫一個吧！<br /><b>使用除錯虛設常式</b><br />虛設的意思就是只剩下殼而沒有內容的常式，原文用stubs（存根）這個字。<br />相較於前置處理器危險的做法，這種做法可以讓編譯器幫你檢查除錯輔助程式的錯誤，並且有和條件編譯有相同的效果。 <br /><pre class="prettyprint"><code>void DoSomething(SOME_TYPE *pointer)<br />&#123;<br />    //check parameters passed in<br />    CheckPoint( pointer );<br />    ...<br />&#125;</code></pre>debug版的程式碼，必須全面性的檢查錯誤，秏時但有效 <br /><pre class="prettyprint"><code>void CheckPinter( void *pointer )<br />&#123;<br />    // perform check 1 -- maybe check that it's not NULL<br />...<br />&#125;</code></pre>release版的程式碼，必須追求效率，可以用下面的程式碼取代上面的程式碼 <br /><pre class="prettyprint"><code>void CheckPinter( void *pointer )<br />&#123;<br />    // no code<br />&#125;<br /></code></pre><br /><br /><h3><span style="font-size: large;">8.7 決定實際實執行所採用的防禦性程式設計程式碼<br />Determining How Much Defensive Programming to Leave in Production Code</span></h3>防禦性程式設計的茅盾之處，就是我們希望在開發時突顯錯誤，在發行時隱藏錯誤。<br />所以，發行之後，還是要保持一些程式碼來對付錯誤，又要保持效率，當中的取捨就是本節的重點。<br /><br /><b>保留檢查重要錯誤的程式碼</b><br /><b>移除檢查次要錯誤的程式碼</b><br /><b>移除導致當機的程式碼</b>（考慮是否影響生命）<br /><b>保留有助於程式妥善當機的程式碼</b><br /><b>記錄錯誤提供給技術人員</b><br /><b>確保保留的錯誤訊息是友善的</b><br /><br /><br /><h3><span style="font-size: large;">8.8 防禦性程式設計的防禦狀態<br />Being Defensive About Defensive Programming</span></h3><div>防禦性程式不可能沒有缺失，請考慮採取的防禦姿態，再安排設計的優先順序。</div>

    
    </section>
    
        <div class="fb-like" data-share="true" data-width="450" data-show-faces="true"></div>
        <section class='ArticleMeta'>
            <div>
                發表於&nbsp;
                <time datetime="2013-02-06T22:28:00.000Z" itemprop="datePublished">
              2013-02-07
            </time>
            </div>
            
                <div>
                    tags:
                    
  <li class="meta-text">
  { <a href="/tags/Code-Complete-2/">Code Complete 2</a> }
  </li>


                </div>
            
        </section>
    
</article>

  <section id="comment">
  <script src="https://utteranc.es/client.js" repo="dwatow/dwatow.github.io" issue-term="title" label="utteranc"
    theme="github-light" crossorigin="anonymous" async>
  </script>
</section>
</div>

                <footer>
    <div>© 2017 - 2024 Chris </div>
    <div>
    Powered by Hexo
    </div>
</footer>

            </div>
        </div>
    </div>
    <script defer src="https://use.fontawesome.com/releases/v5.0.9/js/all.js" integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl" crossorigin="anonymous"></script>
    
<script src="/js/ixbg/ixbg.js"></script>

    
<script src="/js/scrollTop.js"></script>

</body>
</html>
