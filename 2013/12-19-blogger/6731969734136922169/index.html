<!DOCTYPE html>
<html lang="zh-cmn-Hans">
    <head><link rel=manifest href=/manifest.json>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=UA-106752702-1"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());
    gtag("config", "UA-106752702-1");
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <meta itemprop="name" content="Chris's Blog" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta
    itemprop="image"
    content="https://avatars1.githubusercontent.com/u/1825852?v=3&s=460"
  />
  <link rel="canonical" href="https://dwatow.github.io/2013/12-19-blogger/6731969734136922169/"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link
    href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100;0,200;0,300;0,400;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap"
    rel="stylesheet"
  />
  <meta name="description" content="¶Design Pattern 小筆記 原文連結: https:&#x2F;&#x2F;darkblack01.blogspot.com&#x2F;2013&#x2F;12&#x2F;design-pattern.html 移植時的最後更新日期: 2016-04-11T16:17:29.998+08:00 所有的練習我有開一個Github Project模式名稱模式描述、說明模式程式碼簡單工廠模式實作注意：建立一個static function(">
<meta property="og:type" content="article">
<meta property="og:title" content="Design Pattern 小筆記">
<meta property="og:url" content="https://dwatow.github.io/2013/12-19-blogger/6731969734136922169/index.html">
<meta property="og:site_name" content="《Chris 技術筆記》">
<meta property="og:description" content="¶Design Pattern 小筆記 原文連結: https:&#x2F;&#x2F;darkblack01.blogspot.com&#x2F;2013&#x2F;12&#x2F;design-pattern.html 移植時的最後更新日期: 2016-04-11T16:17:29.998+08:00 所有的練習我有開一個Github Project模式名稱模式描述、說明模式程式碼簡單工廠模式實作注意：建立一個static function(">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2013-12-18T21:16:00.003Z">
<meta property="article:modified_time" content="2022-03-05T00:42:54.129Z">
<meta property="article:author" content="Chris">
<meta property="article:tag" content="Design Pattern">
<meta name="twitter:card" content="summary">
  <title>
    Design Pattern 小筆記 - 《Chris 技術筆記》
  </title>
  <meta
    name="viewport"
    content="width=device-width,minimum-scale=1,initial-scale=1"
  />
  <script
    defer
    src="https://cdn.bootcdn.net/ajax/libs/raphael/2.3.0/raphael.min.js"
  ></script>
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="Shell">
        <aside class='SideBar'>
    <canvas id="ixbg" width="100%" height="100%"></canvas>
    <section class='avatar' style="background-image: linear-gradient(to bottom, #1e5799 0%, #f8f8f8 100%)">
    </section>
    <div class='av-pic' style="background-image: url(/assets/head.svg)"></div>
    <section class='menu'>
        <div>《Chris 技術筆記》</div>
        
            <div>設計 × 研究 × 程式</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Lastest</li>
            </a>
          
            <a href="/archives/" class="Btn">
              <li>Posts</li>
            </a>
          
            <a href="/about/" class="Btn">
              <li>Works</li>
            </a>
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>
          
            <a href="/categories/前端新手村/" class="Btn">
              <li>Novice F2E</li>
            </a>
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/dwatow" target="_blank">
                    <i class="fab fa-sm fa-github-alt"></i>
                </a>
            
        
            
                <a href="https://www.facebook.com/dwatow" target="_blank">
                    <i class="fab fa-sm fa-facebook-f"></i>
                </a>
            
        
            
                <a href="https://www.linkedin.com/in/chris-wang-604469107" target="_blank">
                    <i class="fab fa-sm fa-linkedin-in"></i>
                </a>
            
        
    </section>
</aside>

        <div class="container">
            <div data-pager-shell>
                <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Design Pattern 小筆記</h1>
    </header>
    <section>
    
  <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Design-Pattern-%E5%B0%8F%E7%AD%86%E8%A8%98"><span class="toc-text">Design Pattern 小筆記</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">模式名稱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">簡單工廠模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">裝飾模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">工廠方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">樣版模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">外觀模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">觀察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">抽象工廠模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">狀態模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">轉接器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">橋接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">命令模式</span></a></li></ol></li></ol>
  </div>


    <h1 id="Design-Pattern-小筆記"><a class="header-anchor" href="#Design-Pattern-小筆記">¶</a>Design Pattern 小筆記</h1>
<p>原文連結: <a target="_blank" rel="noopener" href="https://darkblack01.blogspot.com/2013/12/design-pattern.html">https://darkblack01.blogspot.com/2013/12/design-pattern.html</a><br>
移植時的最後更新日期: 2016-04-11T16:17:29.998+08:00</p>
<p>所有的練習我有開一個<a href="https://github.com/dwatow/DesignPatternExercise" target="_blank">Github Project</a><br /><br /><br /><br /><br /><h2><span style="font-size: large;">模式名稱</span></h2>模式描述、說明<br /><pre class="prettyprint"><code>模式程式碼</code></pre><br /><br /><br /><br /><br /><h2><span style="font-size: large;">簡單工廠模式</span></h2><b>實作注意：建立一個static function(工廠function)決定(或選擇)建造物件是什麼。</b><br /><span style="color: #cc0000;">利用工廠模式決定產出的物件是什麼(這些物件將會執行相同的行為)</span><br />把creatSomthing放在factory類別中，並且設定成static，使用方式像下面這樣<br /><pre class="prettyprint"><code>something = factory::creatSomething(someThingType);  //靜態工廠</code></pre>工廠做出來的物件，會有相同的一組函式介面，意思是new出來的物件會執行相同的function然後產出物件，並且後續以相同的介面使用該物件。<br /><br /><h2><span style="font-size: large;">策略模式</span></h2><b>實作注意：不同的function(演算法)使用同一組interface，繼承其interface的class目的在於呼叫其內含的function。</b><br /><span style="color: #cc0000;">利用策略決定(選擇)使用的function(或演算法)是什麼。</span><br /><ol><li>將interface放在class中，再繼承interface實作各種演算法。</li><li>將各種演算法放在同一個class，重新定義class的operator()。</li></ol><pre class="prettyprint"><code>omeTea BlackTea(TT_BLACKTEA);<br />BlackTea.shakeStrategy();  //介面=概念執行，不代表演算法實作</code></pre>將演算法打包，我利用operator()()來實作。將演算法包進一個類別裡。(偽造的function)<br /><br /><h2><span style="font-size: large;">裝飾模式</span></h2>call back function實現在物件導向中的做法。<br /><span style="color: #cc0000;">裝飾類別是被call back的function，本體類別是原本的觸發點，使用時才決定call back哪些function，使用相同的interface依序呼叫function。</span><br />本體與裝飾虛類別繼承自相同的interface。<br /><pre class="prettyprint"><code>Ice-&gt;SetDecorator(blackTea);  //設定觸發本體<br />Milk-&gt;SetDecorator(Ice);   //設定觸發本體時，同時又要觸發什麼(裝飾)…<br />//…<br />Milk.CreatDrank();</code></pre>裝飾的設定可以用重載運算子串起來(+或-)。<br /><pre class="prettyprint"><code>blackTea + Ice + Milk /* +… <em>/  //設定觸發的本體+觸發裝飾+觸發裝飾;<br />Milk.CreatDrank();</code></pre>裝飾品裝在本體上，也可以裝在裝飾品上，最後用一個相同的function來串起來(call back)。<br />通常用在<span style="color: #cc0000;">程式執行時才可以決定到底這次要使用哪些function，所以先全部做出來，到時再用裝飾模式</span><br /><br /><h2><span style="font-size: large;">代理模式</span></h2><b>實作注意：設計一個class，擁有原本無法修改設計的class，並且與它繼承自同一個基礎類別。</b><br /><span style="color: #cc0000;">不修改原本的class之下，透明的擴充</span>，擴充特性本身就是proxy的特色<br /><pre class="prettyprint"><code>class proxy<br />&#123;<br />    Excelfile</em> xlsf;  //使用代理模式擴充excel的類別<br />&#125;;</code></pre><b><span style="color: red;">代理與被代理是衍生自同一個父類別。</span></b><br />看似沒有什麼特色的代理模式，可以用來增加介面反應速度(buffer)。<br />使用一組function取代(擴充)真正接觸實體物件時付出的代價。<br /><ul><li>遠端代理（Remote）：代理遠端程時執行，例如我們可以透過WebService的WSDL定義產生中介檔的函式庫，透過這個函式庫就可以存取WebService。</li><li>虛擬代理（Virtual）：將需要秏費大量時間或是複雜的實體，利用代理模式的物件代替。</li><li>安全代理（Protect or Access）：控制物件存取時的許可權。</li><li>智慧參考（Smart Reference）：提供比原有物件更多的服務。</li></ul><br /><h2><span style="font-size: large;">工廠方法模式</span></h2>建構過程做在工廠裡的function，有時建構參數很多，有時建構時要透過另一個臨時的物件當作參數，要先建構它，再建構主要的物件。<br />建立自訂建構過程的construction function群當工廠<br /><br />將變動留給使用者<br />簡單工廠簡化了使用者的程式碼，卻需要不斷的變動工廠的程式碼才可以新增項目<br />工廠方法簡化了新增項目的部份，雖然看似複雜了使用者的程式碼。 <br /><pre class="prettyprint"><code>//用這個決定物件是誰(不過，若要使用switch-case就…和簡單工廠一樣了XD<br />IFactory* factory = new ModFactory();  //在此決定要建的工廠function是什麼(工廠選擇，決定產線內容不同)<br />Operation* oper = factory-&gt;creatOperation();  //在這call construct function</code></pre>工廠從簡單工廠→工廠方法之外，書上還有提到一種「反射」，之後怎麼做就繼續把書看下去吧！<br /><br /><h2><span style="font-size: large;">原型模式</span></h2>複製指標指向的物件。<br /><span style="color: #cc0000;">利用函數複製「指標指向的物件」(包含物件內的成員屬性本身)</span><br />淺複製: 遇到成員指標，只複製其位址。<br />深複製: 遇到成員指標，複製整個物件(在該物件中，設計Clone並繼承prototype class)<br /><pre class="prettyprint"><code>className(const className&amp; myself)  //className自己的建構子<br />&#123;<br />    //other member var<br />    ptr = myself.ptr-&gt;Clone()// 深層複製<br />&#125;</code></pre><pre class="prettyprint"><code>className* Clone()  //className是自己類別的類別名稱<br />&#123;<br />    return new className(<em>this); // new一份自己(物件)回傳出去<br />&#125;</code></pre><br /><h2><span style="font-size: large;">樣版模式</span></h2><b>實作注意：將共同的部份放到父類別，特別的部份放到子類別。<span style="color: #cc0000;">透過父類別中public的function call back子類別中private的function</span>。 </b><br /><pre class="prettyprint"><code>class classBasis<br />&#123;<br />    virtual void Detail() = 0;  //子類別要實作的部份<br />public:<br />    void template()<br />    &#123;<br />        /<em>do some thing</em>/<br />        Detail();<br />    &#125;<br />&#125;;</code></pre><pre class="prettyprint"><code>class classDerivative : public classBasis<br />&#123;<br />    void Detail()&#123;&#125;  //設為private<br />&#125;;</code></pre>FunctionDeri()不可以直接creat子類別的物件，再直接呼叫，一定是被call back的function。<br /><br /><h2><span style="font-size: large;">外觀模式</span></h2><span style="color: #cc0000;">簡化API，隱藏複雜度</span>，將各種類別放到一個類別裡面，透過簡化的fucntion呼叫複雜或多個function，達到簡化的作用；換句話說，外觀模式是建立一個class擁有許多class。<span style="color: #cc0000;">當多個function符合概念整體性，就建造一個外觀。</span><br /><br /><h2><span style="font-size: large;">建造者模式</span></h2><span style="color: #cc0000;">將建造條件與建造細節分開。 </span><br /><ul><li><b>建造條件</b><br />為預防漏掉任何建造條件，<b>利用純虛擬函數<span style="color: #cc0000;">強迫檢查</span></b>是否全部必要的建造條件都有(在衍生類別)覆寫。(有點像工廠方法)</li><li>建造細節</li><li>繼承builder這個純虛擬類別的衍生類別。</li><li><b>建造過程</b><br />擁有將建造條件的純虛擬，簡化介面呼叫(用一個function呼叫很多function)</li></ul><pre class="prettyprint"><code>//建造條件<br />class builder<br />&#123;<br />/<em>constructor or other function</em>/<br />public:<br />    virtual void functionA() = 0;<br />    virtual void functionB() = 0;<br />    virtual void functionC() = 0;<br />&#125;;</code></pre><pre class="prettyprint"><code>//建造細節<br />class builderForTarget<br />&#123;<br />public:<br />    void functionA()&#123;&#125;; //定義建造細節<br />    void functionB()&#123;&#125;;<br />    void functionC()&#123;&#125;;<br />&#125;;</code></pre><pre class="prettyprint"><code>//建造過程<br />class directory<br />&#123;<br />    builder</em> m_builder;  //子類別要實作的部份<br />public:<br />    void function()<br />    &#123;<br />        m_builder-&gt;functionA();<br />        m_builder-&gt;functionB();<br />        m_builder-&gt;functionC();<br />    &#125;<br />&#125;;</code></pre><h2><span style="font-size: large;">觀察者模式</span></h2>做為雙向耦藕合的兩個類別，解耦之用，程式碼如下。 <br />class B的Update()一定要用一個B.cpp裝起來，如果放在B.h的話，call A::Call()會找不到定義。<br />這兩個類別彼此互耦，彼此的關係就是B等A呼叫而跟著更新訊息，所以稱B為觀察者。<br /><pre class="prettyprint"><a target="_blank" rel="noopener" href="//a.h">//a.h</a><br />#include &lt;vector&gt;<br />#include &quot;bbb.h&quot;<br />class A<br />{<br />    std::vector&lt;B*&gt; vb;<br />public:<br />    void Call()<br />    {<br />        for (std::vector&lt;B*&gt;::iterator it = vb.begin(); it != vb.end(); ++it)<br />            (<em>it)-&gt;Update();<br />    }<br />};</pre><pre class="prettyprint"><code><a target="_blank" rel="noopener" href="//b.h">//b.h</a><br />#include &lt;iostream&gt;<br />class A;<br />class B<br />&#123;<br />    A</em> a;<br />public:<br />    void Update();<br />&#125;;</code></pre><pre class="prettyprint"><code><a target="_blank" rel="noopener" href="//b.cpp">//b.cpp</a><br />#include “aaa.h”<br />#include &quot;bbb.h&quot;<br />void B::Update()&#123;  a-&gt;Call(); &#125;</code></pre>程式碼可以解耦成這樣，讓介面與衍生類別耦合。衍生類別透過virtual，可以在定義中操作基礎類別當作是衍生類別。<br /><pre class="prettyprint"><code><a target="_blank" rel="noopener" href="//a0.h">//a0.h</a><br />#include &quot;b0.h&quot;<br />struct A0<br />&#123;<br />    virtual void Add(B0* b) = 0;<br />    virtual void Call() = 0;<br />&#125;;</code></pre><pre class="prettyprint"><code><a target="_blank" rel="noopener" href="//aaa.h">//aaa.h</a><br />#include &lt;vector&gt;<br />#include &quot;a0.h&quot;<br />class A : public A0<br />&#123;<br />    std::vector&lt;B0*&gt; vb;<br />public:<br />    void Add(B0* b)<br />    &#123; vb.push_back(b); &#125;<br />    void Call()<br />    &#123;<br />        for (std::vector&lt;B0*&gt;::iterator it = vb.begin(); it != vb.end(); ++it)<br />            (<em>it)-&gt;Update();<br />    &#125;<br />&#125;;</code></pre><pre class="prettyprint"><a target="_blank" rel="noopener" href="//b0.h">//b0.h</a><br />struct B0<br />{<br />    virtual void Update() = 0;<br />};</pre><pre class="prettyprint"><code><a target="_blank" rel="noopener" href="//bbb.h">//bbb.h</a><br />class B : public B0<br />&#123;<br />    A</em> a;<br />public:<br />    void Update()<br />    &#123; a-&gt;Call(); &#125;;<br />&#125;;</code></pre>這樣的實作方式，常用在<br />Client/Server<br />Document/View<br />這種一個地方修改，其它看見該文件的view都要跟著更新的程式碼。<br />也可以說是重覆利用「call一個function，這個function會call其它function的一種機制」。<br /><br /><h2><span style="font-size: large;">抽象工廠模式</span></h2>簡單工廠模式: 用變數建立物件。<br />工廠方法模式: 用介面建立物件(讓子類別決定建立的物件。)<br />抽象工廠模式: 用介面建立介面(讓子類別決定建立的介面，讓介面操作物件。)<br /><pre class="prettyprint"><code>//用這個決定物件是誰(不過，若要使用switch-case就…和簡單工廠一樣了XD<br />    //iFactory* factory = new SqlSevFactory();<br />    iFactory* factory = new AccessFactory();<br />    <br />    iUser* iu = factory-&gt;createUser();<br />    User* user = new User();<br />    iu-&gt;Insert(user);<br />    iu-&gt;getUser(1);<br /><br />    iDepartment* id = factory-&gt;creatDepartment();<br />    Department* dept = new Department();<br />    id-&gt;Insert(dept);<br />    id-&gt;getDeptName(1);</code></pre><h2><span style="font-size: large;">狀態模式</span></h2>實作注意：將if-else換成一個State類別動態連結的function call，該function定義了各種不同的State的決策(邏輯)內容。<br />function裡描述「狀態的轉換」總是用長長的if-else。<span style="color: red;">和FSM相同的特色在於「目前狀態會決定前往特定的下一個狀態」，不同的地方在於「輸出和狀態有關，還是和輸入有關，在此不重要」。</span>要設計成<b>邏輯與運算分離，邏輯的function就是狀態模式</b>，容易變動的部份就是增減狀態的部份<br /><pre class="prettyprint"><code>#ifndef STATE_H<br />#define STATE_H<br /><br />class Something;  //原本有很長的if-else的class<br /><br />class State<br />&#123;<br />public:<br /> virtual void UpdateState(Something&amp; w) = 0;<br />&#125;;<br />#endif</code></pre><h2><span style="font-size: large;">轉接器模式</span></h2>和proxy代理模式非常的像<br /><ul><li>轉接器模式「轉接與被轉接，不需要衍生自同一個基礎類別」</li><li>代理模式「代理與被代理，都需要洐生自同一個基礎類別」</li></ul>使用時機，能不用就不用，萬一要用的時候，就是沒救的時候了。算是最後一招了！ <br /><br />備忘錄模式<br />組合模式<br />迭代器模式<br />獨體模式<br /><br /><h2><span style="font-size: large;">橋接模式</span></h2>將兩種可形成組識的獨立概念拆開設計。<br />並且可以自由組合成所有排列組合的結果。<br />就像是模組化設計、再組合起來的感覺。<br /><br /><h2><span style="font-size: large;">命令模式</span></h2>用基礎類別指標指向衍生類別物件，將裝著基礎類別指標容器的增加、減少，透過基礎類別的function界面，呼叫真實執行的函數。<br />最後利用動態連結的特性，用一個迴圈一次執行。<br />在增加減少的過程，可以將衍生類別加入容器中。<br /><span style="color: red;">將容器與這一系列的動作包成Command類別，也可以隱藏指標在容器中的複雜度</span>。<br /><br />責任鍊模式</p>

    
    </section>
    
        <div class="fb-like" data-share="true" data-width="450" data-show-faces="true"></div>
        <section class='ArticleMeta'>
            <div>
                發表於&nbsp;
                <time datetime="2013-12-18T21:16:00.003Z" itemprop="datePublished">
              2013-12-19
            </time>
            </div>
            
                <div>
                    tags:
                    
  <li class="meta-text">
  { <a href="/tags/Design-Pattern/">Design Pattern</a> }
  </li>


                </div>
            
        </section>
    
</article>

  <section id="comment">
  <script src="https://utteranc.es/client.js" repo="dwatow/dwatow.github.io" issue-term="title" label="utteranc"
    theme="github-light" crossorigin="anonymous" async>
  </script>
</section>
</div>

                <footer>
    <div>© 2017 - 2025 Chris </div>
    <div>
    Powered by Hexo
    </div>
</footer>

            </div>
        </div>
    </div>
    <script defer src="https://use.fontawesome.com/releases/v5.0.9/js/all.js" integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl" crossorigin="anonymous"></script>
    
<script src="/js/ixbg/ixbg.js"></script>

    
<script src="/js/scrollTop.js"></script>

<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1748049331006')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script><script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1748049331034')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
