<!DOCTYPE html>
<html lang="zh-cmn-Hans">
    <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106752702-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-106752702-1');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta itemprop="name" content="Chris">
  <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/1825852?v=3&s=460">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:ital,wght@0,100;0,200;0,300;0,400;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
  <meta name="description" content="¶用MFC的手操作「真．Excel」 原文連結: https:&#x2F;&#x2F;darkblack01.blogspot.com&#x2F;2013&#x2F;05&#x2F;mfcexcel.html 移植時的最後更新日期: 2013-05-31T08:23:34.826+08:00 這篇文章提及的程式碼，最早是由 自動產生Excel-流浪小築 學來的，這個網站除了這個，還有很多相關的技術可以學唷！很棒的前輩。如果把Excel的OLE加到">
<meta property="og:type" content="article">
<meta property="og:title" content="用MFC的手操作「真．Excel」">
<meta property="og:url" content="https://dwatow.github.io/2013/05-29-blogger/859847402283061114/index.html">
<meta property="og:site_name" content="《Chris 技術筆記》">
<meta property="og:description" content="¶用MFC的手操作「真．Excel」 原文連結: https:&#x2F;&#x2F;darkblack01.blogspot.com&#x2F;2013&#x2F;05&#x2F;mfcexcel.html 移植時的最後更新日期: 2013-05-31T08:23:34.826+08:00 這篇文章提及的程式碼，最早是由 自動產生Excel-流浪小築 學來的，這個網站除了這個，還有很多相關的技術可以學唷！很棒的前輩。如果把Excel的OLE加到">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2013-05-29T10:17:00.000Z">
<meta property="article:modified_time" content="2022-03-02T14:48:10.480Z">
<meta property="article:author" content="Chris">
<meta property="article:tag" content="WIN32 API&#x2F;MFC">
<meta name="twitter:card" content="summary">
  <title>用MFC的手操作「真．Excel」 - 《Chris 技術筆記》</title>
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
  <!-- <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.core.min.js"></script> -->
  <script src="https://cdn.bootcdn.net/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
    
<script src="/js/facebooksdk.js"></script>

    <div class="Shell">
        <aside class='SideBar'>
    <canvas id="ixbg" width="100%" height="100%"></canvas>
    <section class='avatar' style="background-image: linear-gradient(to bottom, #1e5799 0%, #f8f8f8 100%)">
    </section>
    <div class='av-pic' style="background-image: url(/assets/head.svg)"></div>
    <section class='menu'>
        <div>《Chris 技術筆記》</div>
        
            <div>設計 × 研究 × 程式</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Lastest</li>
            </a>
          
            <a href="/archives/" class="Btn">
              <li>Posts</li>
            </a>
          
            <a href="/about/" class="Btn">
              <li>Works</li>
            </a>
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>
          
            <a href="/categories/前端新手村/" class="Btn">
              <li>Novice F2E</li>
            </a>
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/dwatow" target="_blank">
                    <i class="fab fa-sm fa-github-alt"></i>
                </a>
            
        
            
                <a href="https://www.facebook.com/dwatow" target="_blank">
                    <i class="fab fa-sm fa-facebook-f"></i>
                </a>
            
        
            
                <a href="https://www.linkedin.com/in/chris-wang-604469107" target="_blank">
                    <i class="fab fa-sm fa-linkedin-in"></i>
                </a>
            
        
    </section>
</aside>

        <div class="container">
            <div data-pager-shell>
                <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>用MFC的手操作「真．Excel」</h1>
    </header>
    <section>
    
  <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8MFC%E7%9A%84%E6%89%8B%E6%93%8D%E4%BD%9C%E3%80%8C%E7%9C%9F%EF%BC%8EExcel%E3%80%8D"><span class="toc-text">用MFC的手操作「真．Excel」</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">xlsFile.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">xlsFile.cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">簡化初始化動作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">維持 開新檔案&#x2F;開啟舊檔&#x2F;存檔&#x2F;另存新檔 的整體概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">畫出視窗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">對Sheet的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">對儲存格(Cell)的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">選擇儲存格(Cell)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">靠左&#x2F;靠右&#x2F;靠上&#x2F;靠下&#x2F;置中 旋轉&#x2F;文字自動換行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">設定框線粗細、框線顏色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">自動欄寬、列高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">儲存格字型的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">填滿色彩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">Cell填值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">排序演算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">其它</span></a></li></ol></li></ol></li></ol>
  </div>


    <h1 id="用MFC的手操作「真．Excel」"><a class="header-anchor" href="#用MFC的手操作「真．Excel」">¶</a>用MFC的手操作「真．Excel」</h1>
<p>原文連結: <a target="_blank" rel="noopener" href="https://darkblack01.blogspot.com/2013/05/mfcexcel.html">https://darkblack01.blogspot.com/2013/05/mfcexcel.html</a><br>
移植時的最後更新日期: 2013-05-31T08:23:34.826+08:00</p>
<p>這篇文章提及的程式碼，最早是由 <a target="_blank" rel="noopener" href="http://www.intra.idv.tw/data/c_school_4/mfc/auto_excel.htm">自動產生Excel</a>-<a target="_blank" rel="noopener" href="http://www.intra.idv.tw/">流浪小築</a> 學來的，這個網站除了這個，還有很多相關的技術可以學唷！很棒的前輩。<br /><br />如果把Excel的OLE加到MFC的Project也請參考那篇文章就可以了（請務必完全照做一次）。<br />之後對於xlsFile的了解會更有幫助。<br /><br />Excel的程式控制，似乎是辦公室應用裡算是高階的應用。用C<ins>幾乎就是天一般的高度呀（哈哈）畢竟語法細節太多，整個類別全部使用的話，複雜度又太恐怖了。<br />雖然網路上有一個包好的XLSLIB可以使用，但是它…不適合我，我就自己做了一個。<br /><br />這是以操作Excel的概念去設計的類別。每一個函數都盡可能的簡單好用。<br />只是最後插入圖表的部份因為我個人沒有在使用的關係，所以沒有做概念上的最佳化。<br />個人建議使用Design Pattern的組合模式來實現。<br /><br />這個類別有公佈在PTT的CandCpp版、Google code、Github中。<br />在ptt獲得網友Edison.Shin的支援，讓它的功能更豐富。在此完全公開其程式碼提供大家使用。<br /><a name='more'></a><br /><h2><span style="font-size: x-large;">xlsFile.h</span></h2><pre class="prettyprint"><code class="language-cpp">/*******************************************************************<br /> *                                                                 *<br /> * 此class由kx設計，並發佈初版                                        *<br /> * 二版則由Edison.Shih.提供函式，補足初版之不足                        *<br /> *                                                                 *<br /> * 由Edison.Shih.提供的函式補足，會做edisonx的記號                    *<br /> *                                                                 *<br /> * Class由 Visual C</ins> 6 開發                                        <em><br /> * 適用於Microsoft Excel 2003 於 Microsoft Excel 2003 SP3 測試無誤   <em><br /> * 測試平台 Microsoft Windows XP SP3                                <em><br /> *                           2011/7/11                             <em><br /> <em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>/<br />#ifndef XLSFILE_H<br />#define XLSFILE_H<br /><br />#include “excel.h”<br />#include &lt;vector&gt;<br /><br />enum Boarder_Style<br />&#123;<br />    BS_NONE    = 0,      //無框線<br />    BS_SOLIDLINE,        //一般線<br />    BS_BIGDASH,          //小間隔虛線- - - - - -有粗細<br />    BS_SMALLDASH,        //大間隔虛線- - - - - -無粗細<br />    BS_DOTDASH,          //虛線-.-.-.-.-.-.<br />    BS_DASHDOTDOT,       //虛線.-…-…-…-…-.<br />    BS_DOUBLSOLID = 9,   //雙線============（不受粗細改變）<br />    BS_SLASHDASH  = 13   //雙線-/-/-/-/-/-/（不受粗細改變）<br />&#125;;<br />enum Boarder_Weight    //（粗細）<br />&#123;<br />    BA_HAITLINE = 1,     //比一般小（所以用虛線表示）<br />    BA_THIN,             //一般<br />    BA_MEDIUM,           //粗<br />    BA_THICK             //厚<br />&#125;;<br />enum Horizontal_Alignment<br />&#123;<br />    HA_GENERAL = 1,<br />    HA_LEFT,           //edisonx<br />    HA_CENTER,<br />    HA_RIGHT,          //edisonx<br />    HA_FILL,           //重複至填滿    //edisonx<br />    HA_JUSTIFYPARA,    //段落重排（有留白邊，有自動斷行）<br />    HA_CENTERACROSS,   //跨欄置中（不合拼儲存格）<br />    HA_JUSTIFY,        //分散對齊（縮排）<br />&#125;;<br /><br />enum Vertical_Alignment<br />&#123;<br />    VA_TOP = 1,        //edisonx<br />    VA_CENTER,         //edisonx<br />    VA_BOTTOM,         //edisonx<br />    VA_JUSTIFYPARA,    //段落重排（有留白邊，有自動斷行）<br />    VA_JUSTIFY         //分散對齊<br />&#125;;<br /><br />enum Histogram_Chart_Type<br />&#123;<br />    CT_AREA = 0,       //區域<br />    CT_COLUMN,         //方柱<br />    CT_CONE,           //圓錐<br />    CT_CYLINDER,       //圓柱<br />    CT_PYRAMID         //金字塔<br />&#125;;<br /><br />enum Stock_Type<br />&#123;<br />    ST_HLC = 0,    //最高-最低-收盤<br />    ST_OHLC,       //開盤-最高-最低-收盤<br />    ST_VHLC,       //成交量-最高-最低-收盤<br />    ST_VOHLC       //成交量-開盤-最高-最低-收盤<br />&#125;;<br /><br />class xlsFile<br />&#123;<br />protected:<br />    COleVariant   VOptional, VTRUE, VFALSE;  <br />    _Application  objApp;<br />     Workbooks    objBooks;<br />    _Workbook     objBook;<br />     Sheets       objSheets;<br />    _Worksheet    objSheet,objSheetT;<br />    Range         range,col,row;<br />    Interior      cell;<br />    Font          font;<br />    COleException e;<br /><br />    LPDISPATCH    lpDisp;<br />    ChartObjects  chartobjects;<br />    ChartObject   chartobject;<br />    _Chart        xlsChart;<br />    VARIANT       var;<br />    <br />    Shapes        shapes;<br /><br />    char buf[200];  //暫存的字串<br />    char buf1[200];<br />    char buf2[200];<br />      <br />public:<br />    xlsFile();<br />    ~xlsFile();<br />    //回傳xlsFile</em> //開了檔案之後可以繼續選擇Sheet和命名<br />    xlsFile</em> New();<br />    xlsFile</em> Open(const char</em>);<br />    void SaveAs(const char</em>);<br />    void Save();<br />    <br />    void Quit();<br />    void SetVisible(bool);//設定視窗為看得見，並把控制權交給使用者<br />    //----------------------------------------------------<br />    //Sheet操作<br />    long SheetTotal();                     //取得 Sheet 個數<br />    void SetSheetName(short, const char</em>); //由SheetNumber    指定SheetName<br />    CString GetSheetName(short);           //由SheetNumber    取得SheetName<br />    <br />    xlsFile</em> SelectSheet(const char</em>);     //由SheetName      選擇Sheet<br />    xlsFile</em> SelectSheet(short);           //由SheetNumber    選擇Sheet<br />    void CopySheet(const char</em>);           //複製SheetName    指定插入Sheet的位置，並指定新Sheet名稱<br />    void CopySheet(short);                 //複製SheetNumber  指定插入Sheet的位置，並指定名稱<br />    void DelSheet(const char</em>);            //選SheetName      刪除Sheet<br />    void DelSheet(short);                  //選SheetNumber    刪除Sheet<br />    //-----------------------------------------------------<br />    //<br />    long GetHorztlStartCell(); // 起始行<br />    long GetVrticlStartCell(); // 起始列<br />    long GetHorztlTotalCell(); // 總行數<br />    long GetVrticlTotalCell(); // 總列數<br />    //-----------------------------------------------------<br />    //回傳xlsFile</em> 選了格子之後可以繼續下「讀」「寫」的成員函數<br />    //選一格<br />    xlsFile</em> SelectCell(const char</em> );<br />    xlsFile</em> SelectCell(const char</em> , int );<br />    xlsFile</em> SelectCell(char,int);<br />    xlsFile</em> SelectCell(char,char,int);<br />    //選一個範圍<br />    xlsFile</em> SelectCell(const char</em> , const char</em> );<br />    xlsFile</em> SelectCell(const char</em> , int ,const char</em> , int );<br />    xlsFile</em> SelectCell(char,int,char,int);<br />    xlsFile</em> SelectCell(char,char,int,char,char,int);<br />    //--------------------------------------------<br />    void ClearCell();                           //清除儲存格<br />    xlsFile</em> SetMergeCells(short vMerge = TRUE, //合併儲存格（通常會配跨欄置中）<br />                           bool isCenterAcross = true);<br />    //--------------------------------------------<br />    //對齊<br />    xlsFile</em> SetHorztlAlgmet(short);    //水平對齊<br />    xlsFile</em> SetVrticlAlgmet(short);    //垂直對齊<br />    xlsFile</em> SetTextAngle(short Angle); //方向-文字角度<br />    xlsFile</em> AutoNewLine(bool NewLine); //自動換行<br />    //---------------------------------------------<br />    //格線<br />    xlsFile</em> SetCellBorder(long BoarderStyle = 1, <br />    int BoarderWeight = 2, long BoarderColor = 1);  //設定框線粗細和顏色<br />    //---------------------------------------<br />    //儲存格大小<br />    void AutoFitHight();           //自動調整列高<br />    void AutoFitWidth();           //自動調整欄寬<br />    xlsFile</em> SetCellHeight(float); //設定列高<br />    xlsFile</em> SetCellWidth(float);  //設定欄寬<br />    //---------------------------------------------<br />    //字<br />    xlsFile</em> SetFont(const char</em> fontType = “新細明體”);  //設定字型（預設新細明體）<br />    xlsFile</em> SetFontBold(bool isBold = true);           //粗體<br />    xlsFile</em> SetFontStrkthrgh(bool isBold = true);      //刪除線<br />    xlsFile</em> SetFontSize(short fontSize = 12);          //設定字體大小（預設12pt）<br />    xlsFile</em> SetFontColor(short colorIndex = 1);        //字型顏色（預設黑色）<br />    //---------------------------------------------<br />    xlsFile</em> SetCellColor(short);//設定底色<br />    //---------------------------------------------<br />    //（17-32隱藏版也有收進來）<br />    //Microsoft Excel 的顏色排序是依<br />    //紅、橙、黃、綠、藍、靛、紫、灰（y），由深到淺（x）<br />    //不過絕對RGB並沒有規律的存在這個表裡<br />    short SelectColor(short x = 8, short y = 7);   //依excel介面的座標選擇顏色<br />    short SelectColor(const char ColorChar = ‘W’); //快速版（黑D、白W、紅R、綠G、藍B、黃Y）<br />    //---------------------------------------------<br />    //設定資料進儲存格（存成字串）<br />    //一般版<br />    void SetCell(int);<br />    void SetCell(double);<br />    void SetCell(long);    <br />    void SetCell(const char</em> );    <br />    void SetCell(CString );    <br />    //自訂細部格式版<br />    void SetCell(const char</em>, int);<br />    void SetCell(const char</em>, double);<br />    void SetCell(const char</em>, long);<br />    //--------------------------------------------<br />    //取值<br />    int     GetCell2Int();<br />    CString GetCell2CStr();<br />    double  GetCell2Double();<br />    //--------------------------------------------<br />    //排序（依列排序）//edisonx<br />    void Sort(CString IndexCell1     , long DeCrement1,<br />              CString IndexCell2 = “”, long DeCrement2 = 1,<br />              CString IndexCell3 = “”, long DeCrement3 = 1);<br />    //--------------------------------------------<br /><br />    //圖表皆由edisonx提供函數資料<br /><br />    <a target="_blank" rel="noopener" href="//xn--i4q86la274b1w8ad01a.bmp">//儲存圖表圖片.bmp</a>（.jpg亦可以）<br />    void SaveChart(CString FullBmpPathName);<br /><br />    //圖表（三類型的函數在每次建立都要使用）<br />    //使用前必須選擇貼上Chart的儲存格範圍<br />    <br />    //選擇資料範圍<br />    xlsFile</em> SelectChartRange(const char</em> , const char</em> );    <br />    xlsFile</em> SelectChartRange(const char</em> , int ,const char</em> , int );<br />    xlsFile</em> SelectChartRange(char,int,char,int);    <br />    xlsFile</em> SelectChartRange(char,char,int,char,char,int);<br />    //設定Chart參數<br />    xlsFile</em> SetChart(short XaxisByToporLeft = 2, bool isLabelVisable = 1, <br />    CString = “” , CString = “” , CString = “” );<br />    //區域、直方、方柱、圓柱、圓錐、金字塔<br />    void InsertHistogramChart(int shapeType = CT_COLUMN, <br />                              bool is3D = 0, <br />                              int isVrticlorHorztlorOther = 0, <br />                              int isNone_Stack_Percent = 0);<br />    //其它（特殊圖表）   <br />    void InsertBubleChart    (bool is3D    = 0);                          //泡泡圖<br />    void InsertDoughnutChart (bool Explode = 0);                          //圓環圖<br />    void InsertSurfaceChart  (bool is3D    = 0, bool isWire         = 0); //曲面圖<br />    void InsertRadarChart    (bool isWire  = 0, bool isDot          = 1); //雷達圖<br />    void InsertPieChart      (bool Explode = 0, int  type2Dor3DorOf = 0); //圓餅圖<br />    void InsertLineChart     (bool isDot   = 1, bool is3D           = 0, <br />                              int  isNone_Stack_Percent = 0);             //折線圖<br />    void InsertXYScatterChart(bool isDot, bool isLine, bool Smooth);      //離散圖<br />    void InsertStockChart    (int);                                       //股票圖<br />    //--------------------------------------------<br />    void InsertImage(const char</em> , float , float );  //插入圖片<br />    void InsertImage(const char</em> );                  //插入圖片（先選取範圍，圖檔必失真）<br />protected:<br />   void xlsFile::newChart();  //在Sheet新增圖表<br />//    防止任何運算<br />private:<br />    void operator+(const xlsFile&amp;);<br />    void operator-(const xlsFile&amp;);<br />    void operator</em>(const xlsFile&amp;);<br />    void operator/(const xlsFile&amp;);<br />    void operator%(const xlsFile&amp;);<br />    void operator=(const xlsFile&amp;);<br /><br />    bool operator&lt;(const xlsFile&amp;);<br />    bool operator&gt;(const xlsFile&amp;);<br />    bool operator&gt;=(const xlsFile&amp;);<br />    bool operator&lt;=(const xlsFile&amp;);<br />    bool operator==(const xlsFile&amp;);<br />    bool operator!=(const xlsFile&amp;);<br />    bool operator&amp;&amp;(const xlsFile&amp;);<br />    bool operator&amp;(const xlsFile&amp;);<br />    bool operator||(const xlsFile&amp;);<br />    bool operator|(const xlsFile&amp;);<br /><br />    bool operator&gt;&gt;(const xlsFile&amp;);<br />    bool operator&lt;&lt;(const xlsFile&amp;);<br />&#125;;<br />#endif<br /></code></pre><pre class="prettyprint"><code class="language-cpp">//備用語法<br />    range.SetFormula(COleVariant(&quot;=RAND()<em>100000&quot;));  //套公式<br />    range.setSetValue(COleVariant(“Last Name”));      //輸入值<br />    range.SetNumberFormat(COleVariant(&quot;$0.00&quot;));      //數字格式<br /><br />    //插圖<br />    Shapes shapes = objSheet.GetShapes(); <br />    range = objSheet.GetRange(COleVariant(“J7”),COleVariant(“R21”)); <br />  <br />    <a target="_blank" rel="noopener" href="//range.AttachDispatch">//range.AttachDispatch</a>(pRange);<br />    shapes.AddPicture(<br />                    “c:\CHILIN.bmp”,                //LPCTSTR Filename<br />                    false,                           //long    LinkToFile<br />                    true,                            //long    SaveWithDocument<br />                    (float)range.GetLeft(  ).dblVal, //float   Left<br />                    (float)range.GetTop(   ).dblVal, //float   Top<br />                    (float)range.GetWidth( ).dblVal, //float   Width<br />                    (float)range.GetHeight().dblVal  //float   Height<br />    );<br />    range.Sort(<br />                key1,        //  key1<br />                DeCrement1,  // long Order1, [ 1(ascending order) or 2(descending order) ]<br />                key2,        // key2, <br />                VOptional,   // type, [xlSortLabels, xlSortValues]<br />                DeCrement2,  // long Order2, [ 1(升冪) or 2( 降) ]<br />                key3,        // key3<br />                DeCrement3,  // long Order3, [ 1(升冪) or 2( 降) ]<br />                2,           // Header, [0,1 : 不含 title 2 : title （選取範圍）一起排<br />          //進階<br />                VOptional,   // OrderCustom [從1開始，自定義排序順序列表中之索引號，省略使用常規]<br />                _variant_t((short)TRUE),    // MatchCase [TRUE分大小寫排]<br />                1,           // Orientation : [排序方向, 1:按列, 2:按行)<br />                1,           // SortMethod : [1:按字符漢語拼音順序, 2:按字符筆畫數]<br />       //未知選項<br />                1,           // DataOption1 可選 0 與 1<br />                1,           // DataOption2 可選 0 與 1<br />                1            // DataOption3 可選 0 與 1<br />    );</code></pre><h2><span style="font-size: x-large;">xlsFile.cpp</span></h2><h3><span style="font-size: large;">簡化初始化動作</span></h3>在細部操作裡，初始化設計實在是一件，不容易的事。<br />做太多，失去彈性，做太少，又增加函數之間的耦合力，容易讓人產生「誰知道要呼叫這個」的OS。在此，盡量設計的和Excel操作一樣，打開App這一步。而關掉也是設計對應的動作。<br />在construct有一個條件編譯的部份，是在debug模式中，盡快的顯示Excel，但是在release模式中，就把程式化的表格動作結束後，再顯示比較好。<br /><pre class="prettyprint"><code class="language-cpp">xlsFile::xlsFile(): <br />VOptional((long)DISP_E_PARAMNOTFOUND,VT_ERROR), VFALSE((short)FALSE), VTRUE((short)TRUE)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    //Step 1.叫Excel應用程式<br />    if(!objApp.CreateDispatch(“Excel.Application”,&amp;e))<br />    &#123;<br />        CString str;<br />        str.Format(“Excel CreateDispatch() failed w/err 0x%08lx”, e.m_sc);<br />        AfxMessageBox(str, MB_SETFOREGROUND);<br />    &#125;<br />#ifdef _DEBUG<br />    SetVisible(true);<br />#endif<br />&#125;;<br /><br />xlsFile::~xlsFile()<br />&#123;<br />    range.ReleaseDispatch();<br />    objSheet.ReleaseDispatch();<br />    objSheets.ReleaseDispatch();<br />    objBook.ReleaseDispatch();<br />    objBooks.ReleaseDispatch();<br />    objApp.ReleaseDispatch();<br />&#125;</code></pre><h3><span style="font-size: large;">維持 開新檔案/開啟舊檔/存檔/另存新檔 的整體概念</span></h3>概念描述<br /><pre class="prettyprint"><code class="language-cpp">xlsFile</em> xlsFile::New()<br />&#123;<br />    objBooks = objApp.GetWorkbooks();<br />    objBook = objBooks.Add(VOptional);    //開新檔案<br />    objSheets = objBook.GetWorksheets();<br />    return this;<br />&#125;<br /><br />xlsFile</em> xlsFile::Open(const char</em> path)<br />&#123;<br />    objBooks = objApp.GetWorkbooks();<br />    objBook.AttachDispatch(objBooks.Add(_variant_t(path))); //開啟一個已存在的檔案<br />    objBook.Activate();<br />    objSheets = objBook.GetWorksheets();<br />    return this;<br />&#125;<br /><br />void xlsFile::SaveAs(const char</em> strTableName)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf, “%s”, strTableName);<br />    objBook.SaveAs(<br />        COleVariant(buf),<br />        VOptional, VOptional, <br />        VOptional, VOptional, <br />        VOptional, 1,<br />        VOptional, VFALSE,<br />        VOptional, VOptional, VOptional); <br />&#125;<br /><br />void xlsFile::Save()<br />&#123;<br />    objBook.Save();<br />&#125;</code></pre><h3><span style="font-size: large;">畫出視窗</span></h3>就是把視窗畫出來，之後把控制權給使用者。<br /><pre class="prettyprint"><code class="language-cpp">//SetVisible()<br />void xlsFile::SetVisible(bool a)<br />&#123;<br />    objApp.SetVisible(a);    //顯示Excel檔<br />    objApp.SetUserControl(a);//使用者控制後，就不可以自動關閉<br />&#125;<br /></code></pre><h3><span style="font-size: large;">對Sheet的操作</span></h3>其中，在選擇sheet時，常常會出現，程式碼指定選擇一個不存在的sheet，這時出錯了，只有一個空白的MessageBox()，出現了也不知道出了什麼事？哪裡出了問題，所以就在SelectSheet()時做try-catch的設計<br /><pre class="prettyprint"><code class="language-cpp">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br />//Sheet操作<br /><br />//-------------------------<br />////取得 Sheet 個數<br />long xlsFile::SheetTotal()<br />&#123;<br />    return objSheets.GetCount();//edisonx<br />&#125;<br />//-------------------------<br />//由SheetIndex 指定SheetName<br />void xlsFile::SetSheetName(short SheetIndex, const char</em> SheetName)<br />&#123;<br />    try<br />    &#123;<br />        objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />        objSheet.SetName(SheetName);//設定sheet名稱<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“設定第%d個Sheet的名字為%s出錯了！”, SheetIndex, SheetName);<br />        AfxMessageBox(str);<br />    &#125;<br />&#125;<br />//-------------------------<br />//由SheetIndex 取得SheetName<br />CString xlsFile::GetSheetName(short SheetIndex)<br />&#123;<br />    try<br />    &#123;<br />        objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“取得第%d個Sheet名字出錯了！”, SheetIndex);<br />        AfxMessageBox(str);<br />    &#125;<br />    return objSheet.GetName();//edisonx<br />&#125;<br />//-------------------------<br />//選擇Sheet<br />//由SheetName<br />xlsFile</em> xlsFile::SelectSheet(const char</em> SheetName)<br />&#123;<br />    try<br />    &#123;<br />        objSheet = objSheets.GetItem(_variant_t(SheetName));<br />        objSheet.Activate();//edisonx<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“選擇Sheet: %s出錯了！”, SheetName);<br />         AfxMessageBox(str);<br />    &#125;<br />    return this;<br />&#125;<br />//由SheetIndex <br />xlsFile</em> xlsFile::SelectSheet(short SheetIndex)<br />&#123;<br />    try<br />    &#123;<br />        objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />        objSheet.Activate();//edisonx<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“選擇第%d個Sheet出錯了！”, SheetIndex);<br />        AfxMessageBox(str);<br />    &#125;<br />    return this;<br />&#125;<br />//-------------------------<br />//複製SheetName 指定插入Sheet的位置，並指定新Sheet名稱<br />void xlsFile::CopySheet(const char</em> SheetName)<br />&#123;<br />    objSheet.AttachDispatch(objSheets.GetItem(_variant_t(SheetName)),true);<br />    objSheet.Copy(vtMissing,_variant_t(objSheet));<br />&#125;<br />//複製SheetIndex 指定插入Sheet的位置，並指定名稱<br />void xlsFile::CopySheet(short SheetIndex)<br />&#123;<br />    objSheet.AttachDispatch(objSheets.GetItem(COleVariant(SheetIndex)));<br />    objSheet.Copy(vtMissing,_variant_t(objSheet));<br />&#125;<br />//-------------------------<br />//刪除Sheet<br />//選SheetName <br />void xlsFile::DelSheet(const char</em> SheetName)<br />&#123;    <br />    objSheet = objSheets.GetItem(_variant_t(SheetName));<br />    objSheet.Delete();//edisonx<br />&#125;<br />//選SheetIndex<br />void xlsFile::DelSheet(short SheetIndex)<br />&#123;<br />    objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />    objSheet.Delete();//edisonx<br />&#125;</code></pre><h3><span style="font-size: large;">對儲存格(Cell)的操作</span></h3>一般常見的cell操作，都在上面了<br /><pre class="prettyprint"><code class="language-cpp">///////////////////////////////////////////////////////////////////////////////////////////<br />//Cell操作<br />//Cell計數計算<br />// 取得起始列<br />long xlsFile::GetHorztlStartCell()<br />&#123;<br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    return usedrange.GetColumn();<br />&#125;<br />// 取得起始行<br />long xlsFile::GetVrticlStartCell()<br />&#123;    <br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    return usedrange.GetRow();<br />&#125;<br />// 取得總列數<br />long xlsFile::GetHorztlTotalCell()<br />&#123;<br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    range.AttachDispatch(usedrange.GetColumns());<br />    return range.GetCount();<br />&#125;<br />// 取得總行數<br />long xlsFile::GetVrticlTotalCell()<br />&#123;<br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    range.AttachDispatch(usedrange.GetRows());<br />    return range.GetCount();<br />&#125;<br />//清除儲存格<br />void xlsFile::ClearCell()<br />&#123;<br />    //先選取一個範圍的儲存格<br />    range.Clear();//edisonx<br />&#125;<br />//合併儲存格<br />xlsFile</em> xlsFile::SetMergeCells(short vMerge, bool isCenterAcross)<br />&#123;<br />    //先選取一個範圍的儲存格<br />    range.SetMergeCells(_variant_t(vMerge));<br />    if(isCenterAcross) SetHorztlAlgmet(HA_CENTERACROSS);<br />    return this;<br />&#125;</code></pre><h3><span style="font-size: large;">選擇儲存格(Cell)</span></h3>選擇格子的動作，就像是用滑鼠點選儲存格一樣直覺，分成兩種，點選格子和點選範圍<br />其中，和選擇sheet一樣，若出現了選擇了超過Z的格子(用迴圈控制，就可能會超過Z)，就會出問題，也設計了try-catch來顯示出問題的格子在哪<br /><pre class="prettyprint"><code class="language-cpp">//-------------------------<br />//Cell格式設定<br />//-------------------------<br />//選格子<br />//選一格<br />xlsFile</em> xlsFile::SelectCell(const char</em> x)<br />&#123;<br />    try<br />    &#123;<br />        range=objSheet.GetRange(COleVariant(x),COleVariant(x));<br />        ASSERT(range);<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“選擇儲存格%s出錯了！”, x);<br />        AfxMessageBox(str);<br />    &#125;<br />    return this;<br />&#125;<br /><br />xlsFile</em> xlsFile::SelectCell(const char</em> x, int y)<br />&#123;<br />    try<br />    &#123;<br />        ZeroMemory(buf,sizeof(buf));<br />        sprintf(buf,&quot;%s%d&quot;,x,y);<br />        range=objSheet.GetRange(COleVariant(buf),COleVariant(buf));<br />        ASSERT(range);<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“選擇儲存格%s%d出錯了！”, x, y);<br />        AfxMessageBox(str);<br />    &#125;<br />    return this;<br />&#125;<br />//小於Z<br />xlsFile* xlsFile::SelectCell(char x, int y)<br />&#123;<br />    if (x &gt;= ‘A’ &amp;&amp; x &lt;= ‘Z’)<br />    &#123;<br />        ZeroMemory(buf,sizeof(buf));<br />        sprintf(buf,&quot;%c%d&quot;,x,y);<br />        range=objSheet.GetRange(COleVariant(buf),COleVariant(buf));<br />        ASSERT(range);<br />    &#125;<br />    else<br />    &#123;<br />        CString str;<br />        str.Format(“選擇儲存格%c%d出錯了！”, x, y);<br />        AfxMessageBox(str);<br />        ASSERT(x &gt;= ‘A’ &amp;&amp; x &lt;= ‘Z’);<br />    &#125;<br />    return this;<br />&#125;<br />//大於Z，開始選AA<br />xlsFile* xlsFile::SelectCell(char x1, char x2, int y)<br />&#123;<br />    if ( (x1 &gt;= ‘A’ &amp;&amp; x1 &lt;= ‘Z’) &amp;&amp; (x2 &gt;= ‘A’ &amp;&amp; x2 &lt;= ‘Z’))<br />    &#123;<br />        ZeroMemory(buf,sizeof(buf));<br />        sprintf(buf,&quot;%c%c%d&quot;,x1,x2,y);<br />        range=objSheet.GetRange(COleVariant(buf),COleVariant(buf));<br />        ASSERT(range);<br />    &#125;<br />    else<br />    &#123;<br />        CString str;<br />        str.Format(“選擇儲存格%c%c%d出錯了！”, x1, x2, y);<br />        AfxMessageBox(str);<br />        ASSERT(x1 &gt;= ‘A’ &amp;&amp; x1 &lt;= ‘Z’);<br />        ASSERT(x2 &gt;= ‘A’ &amp;&amp; x2 &lt;= ‘Z’);<br />    &#125;<br />    return this;<br />&#125;<br />//-------------------------<br />//選範圍<br />xlsFile* xlsFile::SelectCell(const char* x1, const char* x2)<br />&#123;<br />    try<br />    &#123;<br />        range=objSheet.GetRange(COleVariant(x1),COleVariant(x2));<br />        ASSERT(range);<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“選擇範圍，從%s到%s出錯了！”, x1, x2);<br />        AfxMessageBox(str);<br />    &#125;<br />    return this;<br />&#125;<br /><br />xlsFile* xlsFile::SelectCell(const char* x1, int y1, const char* x2, int y2)<br />&#123;<br />    try<br />    &#123;<br />        ZeroMemory(buf1,sizeof(buf1));<br />        ZeroMemory(buf2,sizeof(buf2));<br />        sprintf(buf1,&quot;%s%d&quot;,x1,y1);<br />        sprintf(buf2,&quot;%s%d&quot;,x2,y2);<br />        range=objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />        ASSERT(range);<br />    &#125;<br />    catch (…)<br />    &#123;<br />        CString str;<br />        str.Format(“選擇範圍，從%s%d到%s%d的地方出錯了！”, x1, y1, x2, y2);<br />        AfxMessageBox(str);<br />    &#125;<br />    return this;<br />&#125;<br />//小於Z<br />xlsFile* xlsFile::SelectCell(char x1, int y1, char x2, int y2)<br />&#123;<br />    if (x1 &gt;= ‘A’ &amp;&amp; x1 &lt;= ‘Z’)<br />    &#123;<br />        ZeroMemory(buf1,sizeof(buf1));<br />        ZeroMemory(buf2,sizeof(buf2));<br />        sprintf(buf1,&quot;%c%d&quot;,x1,y1);<br />        sprintf(buf2,&quot;%c%d&quot;,x2,y2);<br />        range=objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />        ASSERT(range);<br />    &#125;<br />    else<br />    &#123;<br />        CString str;<br />        str.Format(“選擇範圍，從%c%d到%c%d出錯了！”, x1, y1, x2, y2);<br />        AfxMessageBox(str);<br />        ASSERT(x1 &gt;= ‘A’ &amp;&amp; x1 &lt;= ‘Z’);<br />    &#125;<br />    return this;<br />&#125;<br />//大於Z，開始選AA<br />xlsFile* xlsFile::SelectCell(char xA1, char xB1, int y1, char xA2, char xB2, int y2)<br />&#123;<br />    if ( (xA1 &gt;= ‘A’ &amp;&amp; xA2 &lt;= ‘Z’) &amp;&amp; (xB1 &gt;= ‘A’ &amp;&amp; xB2 &lt;= ‘Z’) )<br />    &#123;<br />        ZeroMemory(buf1,sizeof(buf1));<br />        ZeroMemory(buf2,sizeof(buf2));<br />        sprintf(buf1,&quot;%c%c%d&quot;,xA1,xB1,y1);<br />        sprintf(buf2,&quot;%c%c%d&quot;,xA2,xB2,y2);<br />        <br />        range=objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />        ASSERT(range);<br />    &#125;<br />    else<br />    &#123;<br />        CString str;<br />        str.Format(“選擇範圍，從%c%c%d到%c%c%d出錯了！”, xA1, xB1, y1, xA2, xB2, y2);<br />        AfxMessageBox(str);<br />        ASSERT(xA1 &gt;= ‘A’ &amp;&amp; xA2 &lt;= ‘Z’);<br />        ASSERT(xB1 &gt;= ‘A’ &amp;&amp; xB2 &lt;= ‘Z’);<br />    &#125;<br />    return this;<br />&#125;</code></pre><h3><span style="font-size: large;">靠左/靠右/靠上/靠下/置中 旋轉/文字自動換行</span></h3>保持與Excel操作介面相同的思考方式，其參數在.h檔中，有列舉成文字，不需使用數字做辨識，可提高可讀性。<br /><pre class="prettyprint"><code class="language-cpp">//-------------------------<br />//對齊方式<br />//水平對齊<br />xlsFile* xlsFile::SetHorztlAlgmet(short position)<br />&#123;<br />    range.SetHorizontalAlignment(COleVariant(position));<br />    return this;<br />&#125;<br />//垂直對齊<br />xlsFile* xlsFile::SetVrticlAlgmet(short position)<br />&#123;<br />    range.SetVerticalAlignment(COleVariant(position));<br />    return this;<br />&#125;<br />//對齊方式的方向幾度（+90~-90）<br />xlsFile* xlsFile::SetTextAngle(short Angle)<br />&#123;<br />    range.SetOrientation(COleVariant(Angle)); <br />    return this;<br />&#125;<br />//設定文字自動換行<br />xlsFile* xlsFile::AutoNewLine(bool NewLine)<br />&#123;<br />    if(NewLine)    range.SetWrapText(VTRUE);<br />    else           range.SetWrapText(VFALSE);<br />    return this;<br />&#125;</code></pre><h3><span style="font-size: large;">設定框線粗細、框線顏色</span></h3>用同一個介面來設定框線和框線顏色，對於造一個表格來說，是方便的事，若有需要，也可以將它拆開兩個各別處理。但是因為沒有遇到這樣的需求，所以就沒有設計這樣的介面。<br /><pre class="prettyprint"><code class="language-cpp">//設定框線粗細、框線顏色<br />xlsFile* xlsFile::SetCellBorder(long BoarderStyle, int BoarderWeight, long BoarderColor)<br />&#123;<br />    range.BorderAround(_variant_t(BoarderStyle), BoarderWeight, BoarderColor,_variant_t((long)RGB(0,0,0)));<br />    return this;<br />&#125;</code></pre><h3><span style="font-size: large;">自動欄寬、列高</span></h3>在Excel中，只要對著調整格線的地方點兩下，即可適動調整適當欄寬和列高。<br />Excel預設的介面，原本無法一個函數搞定，要先選取整排，再調整。包起來的設計，比較直覺。<br /><pre class="prettyprint"><code class="language-cpp">//設定欄寬列高<br />//自動調整列高<br />void xlsFile::AutoFitWidth()<br />&#123;<br />    col = range.GetEntireColumn();    //選取某個範圍的一整排<br />    col.AutoFit();                    //自動調整一整排的欄寬<br />&#125;<br />//自動調整欄寬<br />void xlsFile::AutoFitHight()<br />&#123;<br />    row = range.GetEntireRow();        //選取某個範圍的一整排<br />    row.AutoFit();                    //自動調整一整排的列高<br />&#125;<br />//設定列高<br />xlsFile* xlsFile::SetCellHeight(float height)<br />&#123;<br />    range.SetRowHeight(_variant_t(height));<br />    return this;<br />&#125;<br />//設定欄寬<br />xlsFile* xlsFile::SetCellWidth(float height)<br />&#123;<br />    range.SetColumnWidth(_variant_t(height));<br />    return this;<br />&#125;</code></pre><h3><span style="font-size: large;">儲存格字型的操作</span></h3>字型的顏色、粗體、字型大小…在工作列上的那一排常用的功能，都建上來了。<br />顏色對照，參考…參考文件！XDDD <br /><pre class="prettyprint"><code class="language-cpp">//設定字型<br />xlsFile* xlsFile::SetFont(const char* fontType)<br />&#123;<br />    font = range.GetFont();<br />    font.SetName(_variant_t(fontType));//原本是韓文字型<br />    return this;<br />&#125;<br />//粗體<br />xlsFile* xlsFile::SetFontBold(bool isBold)<br />&#123;<br />    font = range.GetFont();<br />    if (isBold)    font.SetBold(VTRUE);//粗體<br />    else           font.SetBold(VFALSE);<br />    return this;<br />&#125;<br />//刪除線<br />xlsFile* xlsFile::SetFontStrkthrgh(bool isStrike)<br />&#123;<br />    font = range.GetFont();<br />    if (isStrike)    font.SetStrikethrough(VTRUE);    //edisonx<br />    else             font.SetStrikethrough(VFALSE);    //edisonx<br />    return this;<br />&#125;<br />//字型大小<br />xlsFile* xlsFile::SetFontSize(short fontSize)<br />&#123;<br />    font = range.GetFont();<br />    font.SetSize(_variant_t(fontSize));//字型大小pt<br />    return this;<br />&#125;<br />//字型顏色<br />xlsFile* xlsFile::SetFontColor(short colorIndex)<br />&#123;<br />    font = range.GetFont();<br />    font.SetColorIndex(_variant_t(colorIndex)); //字色(預設黑色)<br />    return this;<br />&#125;</code></pre><h3><span style="font-size: large;">填滿色彩</span></h3>在填滿色彩時，設計了使用座標的方式做操作，此是使用Excel視窗軟體介面上的調色盤的位置為準。<br />除此之外，還有快速選色介面，不過只有幾個純色支援此介面。<br /><pre class="prettyprint"><code class="language-cpp">//設定底色<br />xlsFile* xlsFile::SetCellColor(short colorIndex)<br />&#123;<br />    cell = range.GetInterior();                   //取得選取範圍，設定儲存格的記憶體位址<br />    cell.SetColorIndex(_variant_t(colorIndex));   //設定底色（查表）<br />    <a target="_blank" rel="noopener" href="//cell.SetColor">//cell.SetColor</a>(_variant_t(colorIndex));<br />    return this;<br />&#125;<br />//選擇顏色（適合字色和底色）依excel介面的座標選擇顏色<br />short xlsFile::SelectColor(short x, short y)<br />&#123;<br />//Microsoft Excel 的顏色排序是依<br />//紅、橙、黃、綠、藍、靛、紫、灰（y）<br />//由深到淺（x）<br />    switch(x)<br />    &#123;<br />    case 1:<br />             if(y == 1) return 1;<br />        else if(y == 2) return 9;<br />        else if(y == 3) return 3;<br />        else if(y == 4) return 7;<br />        else if(y == 5) return 38;<br /><br />        else if(y == 6) return 17;<br />        else if(y == 7) return 38;<br />        break;<br />    case 2:<br />             if(y == 1) return 53;<br />        else if(y == 2) return 46;<br />        else if(y == 3) return 45;<br />        else if(y == 4) return 44;<br />        else if(y == 5) return 40;<br />        <br />        else if(y == 6) return 18;<br />        else if(y == 7) return 26;<br />        break;<br />    case 3:<br />             if(y == 1) return 52;<br />        else if(y == 2) return 12;<br />        else if(y == 3) return 43;<br />        else if(y == 4) return  6;<br />        else if(y == 5) return 36;<br />        <br />        else if(y == 6) return 19;<br />        else if(y == 7) return 27;<br />        break;<br />    case 4:<br />             if(y == 1) return 51;<br />        else if(y == 2) return 10;<br />        else if(y == 3) return 50;<br />        else if(y == 4) return  4;<br />        else if(y == 5) return 35;<br />        <br />        else if(y == 6) return 20;<br />        else if(y == 7) return 28;<br />        break;<br />    case 5:<br />             if(y == 1) return 49;<br />        else if(y == 2) return 14;<br />        else if(y == 3) return 42;<br />        else if(y == 4) return  8;<br />        else if(y == 5) return 34;<br />        <br />        else if(y == 6) return 21;<br />        else if(y == 7) return 29;<br />        break;<br />    case 6:<br />             if(y == 1) return 11;<br />        else if(y == 2) return  5;<br />        else if(y == 3) return 41;<br />        else if(y == 4) return 33;<br />        else if(y == 5) return 37;<br />        <br />        else if(y == 6) return 22;<br />        else if(y == 7) return 30;<br />        break;<br />    case 7:<br />             if(y == 1) return 55;<br />        else if(y == 2) return 47;<br />        else if(y == 3) return 13;<br />        else if(y == 4) return 54;<br />        else if(y == 5) return 39;<br />        <br />        else if(y == 6) return 23;<br />        else if(y == 7) return 31;<br />        break;<br />    case 8:<br />             if(y == 1) return 56;<br />        else if(y == 2) return 16;<br />        else if(y == 3) return 48;<br />        else if(y == 4) return 15;<br />        else if(y == 5) return  2;<br />        <br />        else if(y == 6) return 24;<br />        else if(y == 7) return 32;<br />        break;<br />    &#125;<br />    return 2;//預設白色<br />&#125;<br />short xlsFile::SelectColor(const char ColorChar)<br />&#123;<br />    switch(ColorChar)<br />    &#123;<br />    //黑色<br />    case ‘D’:<br />    case ‘d’:<br />        return 1;<br />        break;<br />    //白色<br />    case ‘W’:<br />    case ‘w’:<br />        return 2;<br />        break;<br />    //紅色<br />    case ‘R’:<br />    case ‘r’:<br />        return 3;<br />        break;<br />    //綠色<br />    case ‘G’:<br />    case ‘g’:<br />        return 4;<br />        break;<br />    //藍色<br />    case ‘B’:<br />    case ‘b’:<br />        return 5;<br />        break;<br />    //黃色<br />    case ‘Y’:<br />    case ‘y’:<br />        return 6;<br />        break;    &#125;<br />    return 2;//預設白色<br />&#125;</code></pre><h3><span style="font-size: large;">Cell填值</span></h3>支援格種常用的儲存格格式，但是不支援時間格式。使用上要小心<br /><pre class="prettyprint"><code class="language-cpp">//SetCell()<br />void xlsFile::SetCell(int Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,&quot;%d&quot;,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(long Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,&quot;%d&quot;,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(double Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,&quot;%f&quot;,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(const char* Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    strcpy(buf,Data);<br />    //sprintf(buf,&quot;%s&quot;,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(CString Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,&quot;%s&quot;,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(const char* Format, int Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,Format,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(const char* Format, double Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,Format,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br /><br />void xlsFile::SetCell(const char* Format, long Data)<br />&#123;<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,Format,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />&#125;<br />//-------------------------<br />CString xlsFile::GetCell2CStr()<br />&#123;<br />    return (char*)_bstr_t(range.GetItem(_variant_t((long)1), _variant_t((long)1)));<br />&#125;<br />int xlsFile::GetCell2Int()<br />&#123;<br />    COleVariant vResult = range.GetValue2();   //edisonx <br />    vResult.ChangeType(VT_INT);                //edisonx <br />    return vResult.intVal;                     //edisonx <br />&#125;<br />double xlsFile::GetCell2Double()<br />&#123;<br />    COleVariant vResult = range.GetValue2();  //edisonx <br />    vResult.ChangeType(VT_R8);                //edisonx <br />    return vResult.dblVal;                    //edisonx <br />&#125;</code></pre><h3><span style="font-size: large;">排序演算法</span></h3>排序演算法有分主要順序和次要順序的設定，可以順序填值，也可以填完值再排序。<br /><pre class="prettyprint"><code class="language-cpp">//排序<br />void xlsFile::Sort(CString IndexCell1, long DeCrement1, CString IndexCell2, long DeCrement2, CString IndexCell3, long DeCrement3)<br />&#123;<br />    VARIANT key1, key2, key3;<br /><br />    V_VT(&amp;key1) = VT_DISPATCH;<br />    V_DISPATCH(&amp;key1)=objSheet.GetRange(COleVariant(IndexCell1),COleVariant(IndexCell1));<br /><br />    if(IndexCell2.IsEmpty())<br />    &#123;<br />        range.Sort( key1, DeCrement1, VOptional, VOptional, 1, VOptional, 1, 2,//一般選項<br />                    VOptional, _variant_t((short)TRUE),//進階 <br />                    1, 1, 1, 1, 1);//未知選項//edisonx<br />    &#125;<br />    else<br />    &#123;<br />        V_VT(&amp;key2) = VT_DISPATCH;<br />        V_DISPATCH(&amp;key2)=objSheet.GetRange(COleVariant(IndexCell2),COleVariant(IndexCell2));<br />        <br />        if(IndexCell3.IsEmpty())<br />        &#123;<br />            range.Sort( key1, DeCrement1, key2,    VOptional, DeCrement2, VOptional, 1, 2,<br />                        VOptional, _variant_t((short)TRUE),                                //進階 <br />                        1, 1, 1, 1, 1);                                                    //未知選項//edisonx<br />        &#125;<br />        else<br />        &#123;<br />            V_VT(&amp;key3) = VT_DISPATCH;<br />            V_DISPATCH(&amp;key3)=objSheet.GetRange(COleVariant(IndexCell3),COleVariant(IndexCell3));<br />            <br />            range.Sort( key1, DeCrement1, key2, VOptional, DeCrement2, key3, DeCrement3, 2, //一般選項<br />                        VOptional, _variant_t((short)TRUE),                                 //進階 <br />                        1, 1, 1, 1, 1);                                                     //未知選項//edisonx<br />        &#125;<br />    &#125;<br />&#125;</code></pre><h3><span style="font-size: large;">其它</span></h3>在其它，就將不常用的圖表/圖的新增與設定的操作放在這。<br />這裡的設計就比較不費心思，使用上也許會有種種困擾。小心使用！<br /><pre class="prettyprint"><code class="language-cpp">void xlsFile::newChart()<br />&#123;<br />    //在Sheet新增圖表<br />    lpDisp = objSheet.ChartObjects(VOptional);<br />    chartobjects.AttachDispatch(lpDisp);    <br />    chartobject = chartobjects.Add(<br />                                (float)range.GetLeft(  ).dblVal,<br />                                (float)range.GetTop(   ).dblVal, <br />                                (float)range.GetWidth( ).dblVal, <br />                                (float)range.GetHeight().dblVal  );    //圖表符合儲存格範圍的大小<br />    xlsChart.AttachDispatch(chartobject.GetChart());    //資料來源（範圍left, top預設為 比較Item和Group）<br />&#125;<br />///////////////////////////////////////////////////////////////////////////////////////////<br />//圖表操作<br />//儲存圖表<br />//edisonx<br />void xlsFile::SaveChart(CString FullBmpPathName)<br />&#123;<br />    xlsChart.Export(LPCTSTR(FullBmpPathName),VOptional,VOptional);<br />&#125;<br />//選擇表格資料的範圍<br />xlsFile* xlsFile::SelectChartRange(const char* x1,const char* x2)<br />&#123;<br />    newChart();<br /><br />    lpDisp = objSheet.GetRange(COleVariant(x1),COleVariant(x2));<br />    range.AttachDispatch(lpDisp);<br />    <br />    return this;<br />&#125;<br /><br />xlsFile* xlsFile::SelectChartRange(const char* x1, int y1, const char* x2, int y2)<br />&#123;<br />    newChart();    <br /><br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    sprintf(buf1,&quot;%s%d&quot;,x1,y1);<br />    sprintf(buf2,&quot;%s%d&quot;,x2,y2);<br /><br />    lpDisp = objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />    range.AttachDispatch(lpDisp);<br />    return this;<br />&#125;<br />//小於Z<br />xlsFile* xlsFile::SelectChartRange(char x1, int y1, char x2, int y2)<br />&#123;<br />    newChart();<br /><br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    //發現了這個問題，但是忘記了是不是故意這樣寫的！<br />    //是x1, y1; x2, y2?<br />    sprintf(buf1,&quot;%c%d&quot;,x1,y2);<br />    sprintf(buf2,&quot;%c%d&quot;,x1,y2);<br /><br />    lpDisp = objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />    range.AttachDispatch(lpDisp);<br />    return this;<br />&#125;<br />//大於Z，開始選AA<br />xlsFile* xlsFile::SelectChartRange(char xA1, char xB1, int y1, char xA2, char xB2, int y2)<br />&#123;<br />    newChart();<br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    sprintf(buf1,&quot;%c%c%d&quot;,xA1,xB1,y1);<br />    sprintf(buf2,&quot;%c%c%d&quot;,xA2,xB2,y2);    <br />    lpDisp = objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />    range.AttachDispatch(lpDisp);<br />    return this;<br />&#125;<br />// 設定表格參數（預設會顯示立體直方圖）<br />xlsFile* xlsFile::SetChart(short XaxisByToporLeft, bool isLabelVisable, CString TitleString, CString XaxisTitle, CString YaxisTitle) <br />&#123;    <br />    var.vt = VT_DISPATCH;<br />    var.pdispVal = lpDisp;<br /><br />    short LabelVisable(FALSE);<br />    LabelVisable = (isLabelVisable) ? (short)TRUE : (short)FALSE ;<br />        <br />    xlsChart.ChartWizard(<br />        var,                                   // const VARIANT&amp; Source.<br />        COleVariant((short)11),                // const VARIANT&amp; fix please, Gallery: 3d Column. 1 or 11 是否轉動3D（3D類適用, 1轉，11不轉）<br />        COleVariant((short)1),                 // const VARIANT&amp; fix please, Format, use default<br />        COleVariant(XaxisByToporLeft),         // const VARIANT&amp; PlotBy: 1.X  2.Y 圖表的x軸要使用 表格的1:X-top還是2:Y-left<br />        COleVariant((short)1),                 // const VARIANT&amp; Category Labels fix please 不當軸的那個資料，從第幾個格子開始算（比較群組資料數量）<br />        COleVariant((short)1),                 // const VARIANT&amp; Series Labels. Start X, 不當軸的那個資料，資料名稱要用幾排格子（更改名字）<br />        COleVariant(LabelVisable),             // const VARIANT&amp; HasLegend. 是否要顯示群組資料標籤<br />        //以下可不填<br />        _variant_t(COleVariant(TitleString)),  // const VARITNT&amp; Title<br />        _variant_t(COleVariant(XaxisTitle)),   // const VARIANT&amp; CategoryTitle<br />        _variant_t(COleVariant(YaxisTitle)),   // const VARIANT&amp; ValueTitle<br />        VOptional                              // const VARIANT&amp; ExtraTitle<br />        );<br />    return this;<br />&#125;<br />//插入圖表<br />void xlsFile::InsertHistogramChart(int shapeType, bool is3D, <br />                                   int isVrticl_Horztl_Other, <br />                                   int isNone_Stack_Percent )<br />&#123;<br />    long ChartType = 51;<br />    if (shapeType == 0)//Area<br />    &#123;<br />        if(!is3D)   //2D<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = 1;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 77; //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 76; //有百分比<br />        &#125;<br />        else        //3D<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = -4098; //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 78;    //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 79;    //百分比<br />        &#125;<br />    &#125; <br />    else if (shapeType == 1)//直方圖<br />    &#123;<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        &#123;<br />            if(!is3D)   //2D<br />            &#123;<br />                     if (isNone_Stack_Percent == 0) ChartType = 51; //無堆疊<br />                else if (isNone_Stack_Percent == 1) ChartType = 52; //有堆疊<br />                else if (isNone_Stack_Percent == 2) ChartType = 53; //有百分比<br />            &#125;<br />            else        //3D<br />            &#123;<br />                     if (isNone_Stack_Percent == 0) ChartType = 54; //無堆疊<br />                else if (isNone_Stack_Percent == 1) ChartType = 55; //有堆疊<br />                else if (isNone_Stack_Percent == 2) ChartType = 56; //百分比<br />            &#125;<br />        &#125;<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        &#123;<br />            if(!is3D)   //2D<br />            &#123;<br />                     if (isNone_Stack_Percent == 0) ChartType = 57;<br />                else if (isNone_Stack_Percent == 1) ChartType = 58;<br />                else if (isNone_Stack_Percent == 2) ChartType = 59;<br />            &#125;<br />            else        //3D<br />            &#123;<br />                     if (isNone_Stack_Percent == 0) ChartType = 60;<br />                else if (isNone_Stack_Percent == 1) ChartType = 61;<br />                else if (isNone_Stack_Percent == 2) ChartType = 62;<br />            &#125;<br />        &#125;<br />        else                                        ChartType = -4100;    //平面 必3D<br />    &#125;<br />    else if (shapeType == 2)//CONE<br />    &#123;<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = 92;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 93;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 94;  //百分比<br />        &#125;<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = 95;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 96;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 97;  //百分比<br />        &#125;<br />        else                                    ChartType = 98;  //平面 必3D<br />    &#125;<br />    else if (shapeType == 3)<br />    &#123;<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType =  99;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 100;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 101;  //百分比<br />        &#125;<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        &#123;<br />                  if(isNone_Stack_Percent == 0) ChartType = 102;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 103;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 104;  //百分比<br />        &#125;<br />        else                    ChartType = 105;//平面 必3D<br />    &#125;<br />    else if (shapeType == 4)<br />    &#123;<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = 106;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 107;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 108;  //百分比<br />        &#125;<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = 109;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 110;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 111;  //百分比<br />        &#125;<br />        else                                    ChartType = 112;  //平面 必3D<br />    &#125;<br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br />///////////////////////////////////////////////////////////////<br />//泡泡<br />void xlsFile::InsertBubleChart(bool is3D)<br />&#123;<br />    long ChartType = 51;<br /><br />    if(is3D)    ChartType = 15;<br />    else        ChartType = 87;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br />//圓環<br />void xlsFile::InsertDoughnutChart(bool Explode)<br />&#123;<br />    long ChartType = 51;<br />    <br />    if(!Explode)    ChartType = -4120;<br />    else            ChartType = 80;<br /><br />    xlsChart.SetChartType((long)ChartType);<br /><br />&#125;<br />//曲面<br />void xlsFile::InsertSurfaceChart(bool is3D, bool isWire)<br />&#123;<br />    long ChartType = 51;<br />    <br />    if (is3D)<br />    &#123;<br />        if (!isWire)    ChartType = 83;<br />        else            ChartType = 84;<br />    &#125; <br />    else<br />    &#123;<br />        if (!isWire)    ChartType = 85;<br />        else            ChartType = 86;<br />    &#125;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br />//雷達<br />void xlsFile::InsertRadarChart(bool isWire, bool isDot)<br />&#123;<br />    long ChartType = 51;<br />    <br />    if (isWire)<br />    &#123;<br />        if (!isDot) ChartType = -4151;<br />        else        ChartType = 81;<br />    &#125; <br />    else            ChartType = 82;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br />//圓餅<br />void xlsFile::InsertPieChart(bool Explode, int type2Dor3DorOf)<br />&#123;<br />    long ChartType = 51;<br /><br />    if(!Explode)<br />    &#123;<br />             if (type2Dor3DorOf == 0)        ChartType = 5;<br />        else if (type2Dor3DorOf == 1)        ChartType = -1402;<br />        else if (type2Dor3DorOf == 2)        ChartType = 68;<br />    &#125;<br />    else<br />    &#123;<br />             if (type2Dor3DorOf == 0)        ChartType = 69;<br />        else if (type2Dor3DorOf == 1)        ChartType = 70;<br />        else if (type2Dor3DorOf == 2)        ChartType = 71;<br />    &#125;<br />    <br />    xlsChart.SetChartType(ChartType);<br />&#125;<br /><br />void xlsFile::InsertLineChart(bool isDot, bool is3D, int isNone_Stack_Percent)<br />&#123;<br />    long ChartType = 51;<br />    <br />    if(!is3D)//3D<br />    &#123;<br />        if(!isDot)<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType =  4;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 63;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 64;  //有百分比<br />        &#125;<br />        else<br />        &#123;<br />                 if (isNone_Stack_Percent == 0) ChartType = 65;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 66;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 67;  //有百分比<br />        &#125;<br />    &#125;<br />    else                                        ChartType = -4101;  //3D<br /><br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br />//離散圖<br />void xlsFile::InsertXYScatterChart(bool isDot, bool isLine, bool Smooth)<br />&#123;<br />    long ChartType = 51;<br />    if(!isLine)          ChartType = -4169;  //3D<br />    else<br />    &#123;<br />        if(Smooth)<br />        &#123;<br />            if(isDot)    ChartType = 72;<br />            else         ChartType = 73;<br />        &#125;<br />        else<br />        &#123;<br />            if(isDot)    ChartType = 74;<br />            else         ChartType = 75;<br />        &#125;<br />    &#125;<br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br /><br />//股票圖<br />void xlsFile::InsertStockChart(int StockType)<br />&#123;<br />    long ChartType = 51;<br />    <br />         if (StockType == 0)    ChartType = 88;<br />    else if (StockType == 1)    ChartType = 89;<br />    else if (StockType == 2)    ChartType = 90;<br />    else if (StockType == 3)    ChartType = 91;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />&#125;<br />//--------------------------------------------<br />//--------------------------------------------<br />//插入圖（從檔案）<br />void xlsFile::InsertImage(const char* FileNamePath, float Width, float Height)<br />&#123;<br />    shapes = objSheet.GetShapes(); <br />    shapes.AddPicture(<br />        FileNamePath,                   //LPCTSTR Filename<br />        false,                          //long LinkToFile<br />        true,                           //long SaveWithDocument<br />        (float)range.GetLeft().dblVal,  //float Left<br />        (float)range.GetTop().dblVal,   //float Top<br />        Width,                          //float Width<br />        Height                          //float Height<br />    );<br />&#125;<br /><br />void xlsFile::InsertImage(const char* FileNamePath)<br />&#123;<br />    shapes = objSheet.GetShapes(); <br />    shapes.AddPicture(<br />        FileNamePath,                   //LPCTSTR Filename<br />        false,                          //long LinkToFile<br />        true,                           //long SaveWithDocument<br />        (float)range.GetLeft().dblVal,  //float Left<br />        (float)range.GetTop().dblVal,   //float Top<br />        (float)range.GetWidth().dblVal, //float Width<br />        (float)range.GetHeight().dblVal //float Height<br />    );<br />&#125;</code></pre></p>

    
    </section>
    
        <div class="fb-like" data-share="true" data-width="450" data-show-faces="true"></div>
        <section class='ArticleMeta'>
            <div>
                發表於&nbsp;
                <time datetime="2013-05-29T10:17:00.000Z" itemprop="datePublished">
              2013-05-29
            </time>
            </div>
            
                <div>
                    tags:
                    
  <li class="meta-text">
  { <a href="/tags/WIN32-API-MFC/">WIN32 API/MFC</a> }
  </li>


                </div>
            
        </section>
    
    
        <section id="list_related_posts">
          <h2>同系列文章還有...</h2>
          <ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/2014/06-04-blogger/6291301506449055890/">不知道怎麼跑出來的Executable for debug session Dialog</a><div class="related-posts-item-abstract">¶不知道怎麼跑出來的Executable for debug session Dialog
原文連結: https://darkblack01.blogspot.com</div></li><li class="related-posts-item"><a class="related-posts-link" href="/2014/03-04-blogger/58857659507176918/">清空combBox</a><div class="related-posts-item-abstract">¶清空combBox
原文連結: https://darkblack01.blogspot.com/2014/03/combbox.html
移植時的最後更新日期: 2</div></li><li class="related-posts-item"><a class="related-posts-link" href="/2013/04-26-blogger/9155494380628697561/">PathFileExists()的用法</a><div class="related-posts-item-abstract">¶PathFileExists()的用法
原文連結: https://darkblack01.blogspot.com/2013/04/pathfileexists.h</div></li><li class="related-posts-item"><a class="related-posts-link" href="/2013/04-25-blogger/4411410962580455823/">CString中找關鍵字的技巧</a><div class="related-posts-item-abstract">¶CString中找關鍵字的技巧
原文連結: https://darkblack01.blogspot.com/2013/04/mfc.html
移植時的最後更新日期:</div></li><li class="related-posts-item"><a class="related-posts-link" href="/2013/04-17-blogger/9091447284814344439/">MFC controls//Spin</a><div class="related-posts-item-abstract">¶MFC controls//Spin
原文連結: https://darkblack01.blogspot.com/2013/04/mfc-controlsspin.</div></li><li class="related-posts-item"><a class="related-posts-link" href="/2013/04-15-blogger/6799971123193354473/">抱怨VC6//File: afx.ini Line: 122 的bug</a><div class="related-posts-item-abstract">¶抱怨VC6//File: afx.ini Line: 122 的bug
原文連結: https://darkblack01.blogspot.com/2013/04/</div></li></ul>
        </section>
        <section>
          <div id="gitalk-container"></div>
        </section>
    
</article>

  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '415f51e137fa564654af',
        clientSecret: 'e2912ef418f3ce73af7d465a5ab93bbf374a2228',
        id: window.location.pathname,
        repo: 'dwatow.github.io',
        owner: 'dwatow',
        admin: 'dwatow',
        distractionFreeMode: 'true'
    })
    gitalk.render('gitalk-container')
</script>

</div>

                <footer>
    <div>© 2017 - 2022 Chris </div>
    <div>
    Powered by Hexo
    </div>
</footer>

            </div>
        </div>
    </div>
    <script defer src="https://use.fontawesome.com/releases/v5.0.9/js/all.js" integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl" crossorigin="anonymous"></script>
    
<script src="/js/ixbg/ixbg.js"></script>

    
<script src="/js/scrollTop.js"></script>

</body>
</html>
