---
title: "C++沉思錄//第四章整理"
date: 2014-09-29T23:12:00.001+08:00
tags: 
- "Cpp沉思錄"
- "C_and_Cpp"
categories:
- 舊部落格移植文章
---

# C++沉思錄//第四章整理

原文連結: https://darkblack01.blogspot.com/2014/09/c.html
移植時的最後更新日期: 2015-12-23T14:17:34.167+08:00

<h3><span style="font-size: x-large;">class design checklist</span></h3><ul><li><b>你需要一個建構子嗎？</b></li></ul><div>想一下。</div><ul><li><b>你的成員變數是私有的嗎？</b></li></ul>以函數當作存取成員變數的好處:<br />1. 定義域、值域的程式化。ex: length的長度一定要大於零。<br />2. 算式表示抽象屬性。ex: vector&lt;int&gt;::length(); 元素的數量是取值時才運算出來的。<br /><ul><li><b>你的類別需要一個無參數的建構子嗎？</b></li></ul>利用無參數建構子用來定義成員變數的「預設初始化狀態」。<br /><ul><li><b>是不是每個建構子都初始化所有的成員變數呢？</b></li></ul>雖然建構子是初始化所有的成員變數，但其實在真實世界的例子中，也不是這麼一定。<br />這問題是刺激你思考是否都盡可能的初始化了。<br /><ul><li><b>類別需要解構子嗎？</b></li></ul>思考:<br />1. 這個類別要做些什麼<br />2. 是否有不會由成員函數自動釋放的動態記憶體空間<br />通常，建構子有new出什麼動態記憶體配置，解構子就要delete<br /><ul><li><b>類別需要一個虚擬解構子嗎？</b></li></ul>動態連結時，基礎類別指標是否有必要執行洐生類別的物件的解構子，為了釋放洐生類別的物件才有使用的動態記憶體空間<br /><ul><li><b>你的類別需要自己寫一個複製建構子嗎？</b></li></ul>複製該類別的物件，不相當於「複製其成員變數和基礎類別物件」，則需要複製建構子。<br />如果有動態記憶體宣告的空間，就考慮是否要複製建構子。<br /><ul><li><b>你的類別需要自己寫一個賦值運算子嗎？</b></li></ul>如果有複製建構子，大多需要建立一個。<br />注意返回值要 X&amp; X::operator=()，並且 return *this;<br /><ul><li><b>你的賦值運算子能正確的將物件賦值給物件嗎？</b></li></ul>「自我賦值常常被錯誤的應用，不只是一本C++的書弄錯了」<br />賦值總是用新的值取代舊的值，但是如果「來源物件與目標物件是同一個」，就不可以奉行「先釋放舊值，再複製新值」，會先毀掉來源物件裡的值。<br />在這，有兩個作法<br /><br />1. 判斷是不是賦值給自己，再決定是不是要delete<br /><pre class="prettyprint"><code>xString$ xString::operator=(const xString&amp; xstr)<br />{<br />    if (&s != this)<br />    {<br />        delete [] data;<br />        data = new char[strlen(s.data) + 1];<br />        strcpy(data, s.data);<br />    }<br />    return *this;<br />}</code></pre>2. 先暫存，再賦值，最後再delete <br /><pre class="prettyprint"><code>xString$ xString::operator=(const xString&amp; xstr)<br />{<br /><br />    char* newdata = new char[strlen(s.data) + 1];<br />    strcpy(newdata, s.data);<br />    delete [] data;<br />    data = newdata;    <br />    return *this;<br />}</code></pre><ul><li><b>你的類別需要關係運算子嗎？</b></li></ul>只要用戶想要排序你的類，你就必須要提供關係運算子。<br /><ul><li><b>刪除陣列時你記得使用delete[]嗎？</b></li></ul>會保留這種奇怪的寫法，是為了和C語言相容，同時保有效率。<br /><br /><ul><li><b>記得在複製建構子和賦值運算子的參數加上const了嗎？</b></li></ul><div>提供保證，複製物件並不會改變原物件。</div><ul><li><b>如果函數的參數是參考，它們是否該加上const？</b></li></ul><div>只有當函數想改變參數時，才會取消加上const</div><ul><li><b>記得適當的宣告成員函數成const了嗎？</b></li></ul>有設定唯讀的函數，才可以套用在STL的演算法中執行。<br /><div><br /></div>
