---
title: "C++單元測試(6) - Game Programing Game 6 Ch1.7 首部曲"
date: 2014-10-19T21:10:00.000+08:00
tags: 
- "TDD"
categories:
- 舊部落格移植文章
---

# C++單元測試(6) - Game Programing Game 6 Ch1.7 首部曲

原文連結: https://darkblack01.blogspot.com/2014/10/cgame-programing-game-6-ch17.html
移植時的最後更新日期: 2015-12-26T14:17:37.593+08:00

我一直覺得CppUnit的文件太少了，其實，也許是自己太弱了，所以才要這麼多的文件來教自己用這個厲害的工具。<br /><br />試過了<a href="http://darkblack01.blogspot.tw/2014/08/c3-vc6-cppunit.html">用VC6編譯cppunitlib</a>與<a href="http://darkblack01.blogspot.tw/2014/09/c4-vs2010-cppunit.html">用VS2010編譯cppunitlib</a>，我還有另外去試了VS2005，結果<strike>也是超順利的編譯完成</strike><a href="http://darkblack01.blogspot.tw/2015/05/c7-vs2005.html" target="_blank">vs2005會遇到專案檔轉換出錯的問題</a>，排除後就沒有特別要注意的地方了。(所以就沒有另外寫一篇介紹2005的了)<br /><strike>秘訣：<span style="color: red;">更新該版本的VS到最新版</span>！</strike><br />然後小心專案檔的設定。(參考上述兩篇)<br /><br />還記得，我們在<a href="http://darkblack01.blogspot.tw/2014/07/cppunit.html" target="_blank">本系列第一篇</a>中有提到到CppUnit的wiki有看到Refreance的段落吧？其實，有一個梗...不是啦！有一篇文章千千萬萬不可以錯過。那就是CppUnit1.13.2的作者在《Game Programming Gems 6》的Ch1.7寫了一篇CppUnit的教學。算是比<a href="http://cppunit.sourceforge.net/doc/1.8.0/cppunit_cookbook.html" target="_blank">CppUnit CookBook</a>介紹得還要多一點點的教學文章。<br /><br />所以，有興趣的朋友可以去下載來看看。<br /><br />在這裡，我有依照這本書的1.7章做了練習，放在github上。<br />上面寫了一樣的code(還修改了一個小錯誤)，也寫上了註解，很多的註解。<br />有興趣的朋友可以來<a href="https://github.com/dwatow/gpg6_ch1_7/" target="_blank">這裡</a>下載回去看看。<br /><br />不過因為它是TDD，所以沒有待測物的class，只有完成了測試程式的部份。不過待測物很好寫啦！可以自己寫一寫....就可以跑囉！<br /><br /><br />《Game Programming Gems 6》的Ch1.7的內容，在這個部落格會分成三篇介紹。但是最重要的，還是要下載程式碼回去看唷！git就可以可以讓你一步一步的練習呢！<br /><br /><h2><span style="font-size: x-large;">第一部曲</span></h2>(34fe339~55c32ea)<br /><h3><span style="font-size: large;">建立治具類別</span></h3><pre class="prettyprint"><code>#ifndef FIXTURE_CLASS_H<br />#define FIXTURE_CLASS_H<br />#include "CppunitLib.h"<br />/*<br />在Cppunit中，我們要先建立治具類別。這可以從CppUnit::TestFixture衍生取得。<br />測試治具類別，就是一個容器類別，用來管理那些用於測試特定函數或類別的所有測試案例。<br />一個空的測試治具類別大致如下：<br />*/<br />class MathTest : public CppUnit::TestFixture<br />{<br />public:<br />    CPPUNIT_TEST_SUITE(MathTest);   //MathTest是TestFixture的衍生Class<br />    CPPUNIT_TEST_SUITE_END();<br />};<br />#endif</code></pre><h3><span style="font-size: large;">在治具類別上面放上待測物，再加上測試的功能內容</span></h3><pre class="prettyprint"><code>#ifndef FIXTURE_CLASS_H<br />#define FIXTURE_CLASS_H<br />#include "CppunitLib.h"<br />/*<br />在Cppunit中，我們要先建立治具類別。這可以從CppUnit::TestFixture衍生取得。<br />測試治具類別，就是一個容器類別，用來管理那些用於測試特定函數或類別的所有測試案例。<br />一個空的測試治具類別大致如下：<br />*/<br />class MathTest : public CppUnit::TestFixture<br />{<br />    /*<br />    在其中CPPUNIT_TEST_SUITE的巨集說明中，我們要說明這個測試治具類別執行的所有測試案例。<br />    例如，假設這個測試治具別要測試一個math類別，<br />    而你又需要一個特殊測試案例，來測試這個math類取的add函數。<br />    你可以像下面這段程式碼一樣，建立一個測試用的函數，來完成上述的實作。<br />    */<br />public:<br />    void TestAddFunction()<br />    {<br />        math my_math;<br />        CPPUNIT_ASSERT(my_math.Add(2, 2) == 4);<br />    }<br />    /*<br />    在這個測試案例中，我們呼叫math.add(2, 2)，利用CppUnit提供的CPPUNIT_ASSRT巨集來驗證add呼叫的結果是否等於4。<br />    如果add函數沒有正確的返回結果4，CppUnit會在日誌文件中將這個錯誤記錄下來，並根據你所設置的報告輸出方式<br />    為你顯示這個錯誤訊息。<br /><br />    在完成這個測試案例的實作之後，你要用CPPUNIT_TEST_SUITE巨集，將這個測試案例<br />    添加到測試治具類別中。<br />    */<br />public:<br />    CPPUNIT_TEST_SUITE(MathTest);   //MathTest是TestFixture的衍生Class<br />    CPPUNIT_TEST(TestAddFunction);  //TestAddFunction是待測的Function<br />    CPPUNIT_TEST_SUITE_END();<br />};<br />#endif</code></pre><h3><span style="font-size: large;">在測試主程式中寫下你要輸出的格式是什麼，並且執行</span></h3><pre class="prettyprint"><code>#include "CppunitLib.h"<br />#include "FixtureClass.h"<br />#include &lt;iostream&gt;<br /><br />/*<br />既然你已經完成了撰寫測試案例的工作，並將它們添加到一個測試治具類別中進行管理，<br />現在你就需要建立一個測試執行模組(test harness)，它會實際的執行這個測試治具類別(像工廠的機台)，<br />並輸出最後執行結果。<br /><br />我們可以這樣做:<br />1. 建立一個CppUnit::TextTestRunner物件，<br />2. 添加測試治具類別到CppUnit::TextTestRunner物件<br />3. 設定輸果的輸出格式<br />4. 執行CppUnit::TextTestRunner物件。<br /><br />以這個例子來說，你可以將輸出結果重新定到一個xml文件中。<br />這個xml文件使用了一個樣式表來顯示輸出結果，更方便於瀏覽。<br />*/<br /><br />int main()<br />{<br /> //第一步，就是建立測試的執行物件，一個CppUnit::TextTestRunner物件<br /> CppUnit::TextTestRunner runner;<br /> <br /> //接下來，建立output stream，指向我們保存輸出結果的xml檔。<br /> std::ofstream ofs("tests.xml");<br /><br /> //要建立這個xml檔的handle(是一個CppUnit::XmlOutputter物件)<br /> //設定它的樣式表<br /> //設定runner的執行結果由hanle處理<br /> CppUnit::XmlOutputter *xml =<br />  new CppUnit::XmlOutputter(&amp;runner.result(), ofs);<br /> xml-&gt;setStyleSheet("report.xsl");<br /> runner.setOutputter(xml);<br /><br /> //最後，將所有你要執行的測試治具別(MathTest)加到這個runner物件<br /> runner.addTest(MathTest::suite());<br /> runner.run();<br /><br /> std::cout &lt;&lt; "end unti test" &lt;&lt; std::endl;<br /> getchar();<br /><br /> return 0;<br />}</code></pre><br />
