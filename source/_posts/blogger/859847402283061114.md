---
title: 用MFC的手操作「真．Excel」
date: 2013-05-30T02:17:00.000+08:00
tags: 
- WIN32 API/MFC

categories:
- 舊部落格移植文章
---

# 用MFC的手操作「真．Excel」

原文連結: https://darkblack01.blogspot.com/2013/05/mfcexcel.html
移植時的最後更新日期: 2013-05-31T08:23:34.826+08:00

這篇文章提及的程式碼，最早是由&nbsp;<a href="http://www.intra.idv.tw/data/c_school_4/mfc/auto_excel.htm">自動產生Excel</a>-<a href="http://www.intra.idv.tw/">流浪小築</a>&nbsp;學來的，這個網站除了這個，還有很多相關的技術可以學唷！很棒的前輩。<br /><br />如果把Excel的OLE加到MFC的Project也請參考那篇文章就可以了（請務必完全照做一次）。<br />之後對於xlsFile的了解會更有幫助。<br /><br />Excel的程式控制，似乎是辦公室應用裡算是高階的應用。用C++幾乎就是天一般的高度呀（哈哈）畢竟語法細節太多，整個類別全部使用的話，複雜度又太恐怖了。<br />雖然網路上有一個包好的XLSLIB可以使用，但是它....不適合我，我就自己做了一個。<br /><br />這是以操作Excel的概念去設計的類別。每一個函數都盡可能的簡單好用。<br />只是最後插入圖表的部份因為我個人沒有在使用的關係，所以沒有做概念上的最佳化。<br />個人建議使用Design Pattern的組合模式來實現。<br /><br />這個類別有公佈在PTT的CandCpp版、Google code、Github中。<br />在ptt獲得網友Edison.Shin的支援，讓它的功能更豐富。在此完全公開其程式碼提供大家使用。<br /><a name='more'></a><br /><h2><span style="font-size: x-large;">xlsFile.h</span></h2><pre class="prettyprint"><code class="language-cpp">/*******************************************************************<br /> *                                                                 *<br /> * 此class由kx設計，並發佈初版                                        *<br /> * 二版則由Edison.Shih.提供函式，補足初版之不足                        *<br /> *                                                                 *<br /> * 由Edison.Shih.提供的函式補足，會做edisonx的記號                    *<br /> *                                                                 *<br /> * Class由 Visual C++ 6 開發                                        *<br /> * 適用於Microsoft Excel 2003 於 Microsoft Excel 2003 SP3 測試無誤   *<br /> * 測試平台 Microsoft Windows XP SP3                                *<br /> *                           2011/7/11                             *<br /> *******************************************************************/<br />#ifndef XLSFILE_H<br />#define XLSFILE_H<br /><br />#include "excel.h"<br />#include &lt;vector&gt;<br /><br />enum Boarder_Style<br />{<br />    BS_NONE    = 0,      //無框線<br />    BS_SOLIDLINE,        //一般線<br />    BS_BIGDASH,          //小間隔虛線- - - - - -有粗細<br />    BS_SMALLDASH,        //大間隔虛線- - - - - -無粗細<br />    BS_DOTDASH,          //虛線-.-.-.-.-.-.<br />    BS_DASHDOTDOT,       //虛線.-..-..-..-..-.<br />    BS_DOUBLSOLID = 9,   //雙線============（不受粗細改變）<br />    BS_SLASHDASH  = 13   //雙線-/-/-/-/-/-/（不受粗細改變）<br />};<br />enum Boarder_Weight    //（粗細）<br />{<br />    BA_HAITLINE = 1,     //比一般小（所以用虛線表示）<br />    BA_THIN,             //一般<br />    BA_MEDIUM,           //粗<br />    BA_THICK             //厚<br />};<br />enum Horizontal_Alignment<br />{<br />    HA_GENERAL = 1,<br />    HA_LEFT,           //edisonx<br />    HA_CENTER,<br />    HA_RIGHT,          //edisonx<br />    HA_FILL,           //重複至填滿    //edisonx<br />    HA_JUSTIFYPARA,    //段落重排（有留白邊，有自動斷行）<br />    HA_CENTERACROSS,   //跨欄置中（不合拼儲存格）<br />    HA_JUSTIFY,        //分散對齊（縮排）<br />};<br /><br />enum Vertical_Alignment<br />{<br />    VA_TOP = 1,        //edisonx<br />    VA_CENTER,         //edisonx<br />    VA_BOTTOM,         //edisonx<br />    VA_JUSTIFYPARA,    //段落重排（有留白邊，有自動斷行）<br />    VA_JUSTIFY         //分散對齊<br />};<br /><br />enum Histogram_Chart_Type<br />{<br />    CT_AREA = 0,       //區域<br />    CT_COLUMN,         //方柱<br />    CT_CONE,           //圓錐<br />    CT_CYLINDER,       //圓柱<br />    CT_PYRAMID         //金字塔<br />};<br /><br />enum Stock_Type<br />{<br />    ST_HLC = 0,    //最高-最低-收盤<br />    ST_OHLC,       //開盤-最高-最低-收盤<br />    ST_VHLC,       //成交量-最高-最低-收盤<br />    ST_VOHLC       //成交量-開盤-最高-最低-收盤<br />};<br /><br />class xlsFile<br />{<br />protected:<br />    COleVariant   VOptional, VTRUE, VFALSE;  <br />    _Application  objApp;<br />     Workbooks    objBooks;<br />    _Workbook     objBook;<br />     Sheets       objSheets;<br />    _Worksheet    objSheet,objSheetT;<br />    Range         range,col,row;<br />    Interior      cell;<br />    Font          font;<br />    COleException e;<br /><br />    LPDISPATCH    lpDisp;<br />    ChartObjects  chartobjects;<br />    ChartObject   chartobject;<br />    _Chart        xlsChart;<br />    VARIANT       var;<br />    <br />    Shapes        shapes;<br /><br />    char buf[200];  //暫存的字串<br />    char buf1[200];<br />    char buf2[200];<br />      <br />public:<br />    xlsFile();<br />    ~xlsFile();<br />    //回傳xlsFile* //開了檔案之後可以繼續選擇Sheet和命名<br />    xlsFile* New();<br />    xlsFile* Open(const char*);<br />    void SaveAs(const char*);<br />    void Save();<br />    <br />    void Quit();<br />    void SetVisible(bool);//設定視窗為看得見，並把控制權交給使用者<br />    //----------------------------------------------------<br />    //Sheet操作<br />    long SheetTotal();                     //取得 Sheet 個數<br />    void SetSheetName(short, const char*); //由SheetNumber    指定SheetName<br />    CString GetSheetName(short);           //由SheetNumber    取得SheetName<br />    <br />    xlsFile* SelectSheet(const char*);     //由SheetName      選擇Sheet<br />    xlsFile* SelectSheet(short);           //由SheetNumber    選擇Sheet<br />    void CopySheet(const char*);           //複製SheetName    指定插入Sheet的位置，並指定新Sheet名稱<br />    void CopySheet(short);                 //複製SheetNumber  指定插入Sheet的位置，並指定名稱<br />    void DelSheet(const char*);            //選SheetName      刪除Sheet<br />    void DelSheet(short);                  //選SheetNumber    刪除Sheet<br />    //-----------------------------------------------------<br />    //<br />    long GetHorztlStartCell(); // 起始行<br />    long GetVrticlStartCell(); // 起始列<br />    long GetHorztlTotalCell(); // 總行數<br />    long GetVrticlTotalCell(); // 總列數<br />    //-----------------------------------------------------<br />    //回傳xlsFile* 選了格子之後可以繼續下「讀」「寫」的成員函數<br />    //選一格<br />    xlsFile* SelectCell(const char* );<br />    xlsFile* SelectCell(const char* , int );<br />    xlsFile* SelectCell(char,int);<br />    xlsFile* SelectCell(char,char,int);<br />    //選一個範圍<br />    xlsFile* SelectCell(const char* , const char* );<br />    xlsFile* SelectCell(const char* , int ,const char* , int );<br />    xlsFile* SelectCell(char,int,char,int);<br />    xlsFile* SelectCell(char,char,int,char,char,int);<br />    //--------------------------------------------<br />    void ClearCell();                           //清除儲存格<br />    xlsFile* SetMergeCells(short vMerge = TRUE, //合併儲存格（通常會配跨欄置中）<br />                           bool isCenterAcross = true);<br />    //--------------------------------------------<br />    //對齊<br />    xlsFile* SetHorztlAlgmet(short);    //水平對齊<br />    xlsFile* SetVrticlAlgmet(short);    //垂直對齊<br />    xlsFile* SetTextAngle(short Angle); //方向-文字角度<br />    xlsFile* AutoNewLine(bool NewLine); //自動換行<br />    //---------------------------------------------<br />    //格線<br />    xlsFile* SetCellBorder(long BoarderStyle = 1, <br />    int BoarderWeight = 2, long BoarderColor = 1);  //設定框線粗細和顏色<br />    //---------------------------------------<br />    //儲存格大小<br />    void AutoFitHight();           //自動調整列高<br />    void AutoFitWidth();           //自動調整欄寬<br />    xlsFile* SetCellHeight(float); //設定列高<br />    xlsFile* SetCellWidth(float);  //設定欄寬<br />    //---------------------------------------------<br />    //字<br />    xlsFile* SetFont(const char* fontType = "新細明體");  //設定字型（預設新細明體）<br />    xlsFile* SetFontBold(bool isBold = true);           //粗體<br />    xlsFile* SetFontStrkthrgh(bool isBold = true);      //刪除線<br />    xlsFile* SetFontSize(short fontSize = 12);          //設定字體大小（預設12pt）<br />    xlsFile* SetFontColor(short colorIndex = 1);        //字型顏色（預設黑色）<br />    //---------------------------------------------<br />    xlsFile* SetCellColor(short);//設定底色<br />    //---------------------------------------------<br />    //（17-32隱藏版也有收進來）<br />    //Microsoft Excel 的顏色排序是依<br />    //紅、橙、黃、綠、藍、靛、紫、灰（y），由深到淺（x）<br />    //不過絕對RGB並沒有規律的存在這個表裡<br />    short SelectColor(short x = 8, short y = 7);   //依excel介面的座標選擇顏色<br />    short SelectColor(const char ColorChar = 'W'); //快速版（黑D、白W、紅R、綠G、藍B、黃Y）<br />    //---------------------------------------------<br />    //設定資料進儲存格（存成字串）<br />    //一般版<br />    void SetCell(int);<br />    void SetCell(double);<br />    void SetCell(long);    <br />    void SetCell(const char* );    <br />    void SetCell(CString );    <br />    //自訂細部格式版<br />    void SetCell(const char*, int);<br />    void SetCell(const char*, double);<br />    void SetCell(const char*, long);<br />    //--------------------------------------------<br />    //取值<br />    int     GetCell2Int();<br />    CString GetCell2CStr();<br />    double  GetCell2Double();<br />    //--------------------------------------------<br />    //排序（依列排序）//edisonx<br />    void Sort(CString IndexCell1     , long DeCrement1,<br />              CString IndexCell2 = "", long DeCrement2 = 1,<br />              CString IndexCell3 = "", long DeCrement3 = 1);<br />    //--------------------------------------------<br /><br />    //圖表皆由edisonx提供函數資料<br /><br />    //儲存圖表圖片.bmp（.jpg亦可以）<br />    void SaveChart(CString FullBmpPathName);<br /><br />    //圖表（三類型的函數在每次建立都要使用）<br />    //使用前必須選擇貼上Chart的儲存格範圍<br />    <br />    //選擇資料範圍<br />    xlsFile* SelectChartRange(const char* , const char* );    <br />    xlsFile* SelectChartRange(const char* , int ,const char* , int );<br />    xlsFile* SelectChartRange(char,int,char,int);    <br />    xlsFile* SelectChartRange(char,char,int,char,char,int);<br />    //設定Chart參數<br />    xlsFile* SetChart(short XaxisByToporLeft = 2, bool isLabelVisable = 1, <br />    CString = "" , CString = "" , CString = "" );<br />    //區域、直方、方柱、圓柱、圓錐、金字塔<br />    void InsertHistogramChart(int shapeType = CT_COLUMN, <br />                              bool is3D = 0, <br />                              int isVrticlorHorztlorOther = 0, <br />                              int isNone_Stack_Percent = 0);<br />    //其它（特殊圖表）   <br />    void InsertBubleChart    (bool is3D    = 0);                          //泡泡圖<br />    void InsertDoughnutChart (bool Explode = 0);                          //圓環圖<br />    void InsertSurfaceChart  (bool is3D    = 0, bool isWire         = 0); //曲面圖<br />    void InsertRadarChart    (bool isWire  = 0, bool isDot          = 1); //雷達圖<br />    void InsertPieChart      (bool Explode = 0, int  type2Dor3DorOf = 0); //圓餅圖<br />    void InsertLineChart     (bool isDot   = 1, bool is3D           = 0, <br />                              int  isNone_Stack_Percent = 0);             //折線圖<br />    void InsertXYScatterChart(bool isDot, bool isLine, bool Smooth);      //離散圖<br />    void InsertStockChart    (int);                                       //股票圖<br />    //--------------------------------------------<br />    void InsertImage(const char* , float , float );  //插入圖片<br />    void InsertImage(const char* );                  //插入圖片（先選取範圍，圖檔必失真）<br />protected:<br />   void xlsFile::newChart();  //在Sheet新增圖表<br />//    防止任何運算<br />private:<br />    void operator+(const xlsFile&amp;);<br />    void operator-(const xlsFile&amp;);<br />    void operator*(const xlsFile&amp;);<br />    void operator/(const xlsFile&amp;);<br />    void operator%(const xlsFile&amp;);<br />    void operator=(const xlsFile&amp;);<br /><br />    bool operator&lt;(const xlsFile&amp;);<br />    bool operator&gt;(const xlsFile&amp;);<br />    bool operator&gt;=(const xlsFile&amp;);<br />    bool operator&lt;=(const xlsFile&amp;);<br />    bool operator==(const xlsFile&amp;);<br />    bool operator!=(const xlsFile&amp;);<br />    bool operator&amp;&amp;(const xlsFile&amp;);<br />    bool operator&amp;(const xlsFile&amp;);<br />    bool operator||(const xlsFile&amp;);<br />    bool operator|(const xlsFile&amp;);<br /><br />    bool operator&gt;&gt;(const xlsFile&amp;);<br />    bool operator&lt;&lt;(const xlsFile&amp;);<br />};<br />#endif<br /></code></pre><pre class="prettyprint"><code class="language-cpp">//備用語法<br />    range.SetFormula(COleVariant("=RAND()*100000"));  //套公式<br />    range.setSetValue(COleVariant("Last Name"));      //輸入值<br />    range.SetNumberFormat(COleVariant("$0.00"));      //數字格式<br /><br />    //插圖<br />    Shapes shapes = objSheet.GetShapes(); <br />    range = objSheet.GetRange(COleVariant("J7"),COleVariant("R21")); <br />  <br />    //range.AttachDispatch(pRange);<br />    shapes.AddPicture(<br />                    "c:\\CHILIN.bmp",                //LPCTSTR Filename<br />                    false,                           //long    LinkToFile<br />                    true,                            //long    SaveWithDocument<br />                    (float)range.GetLeft(  ).dblVal, //float   Left<br />                    (float)range.GetTop(   ).dblVal, //float   Top<br />                    (float)range.GetWidth( ).dblVal, //float   Width<br />                    (float)range.GetHeight().dblVal  //float   Height<br />    );<br />    range.Sort(<br />                key1,        //  key1<br />                DeCrement1,  // long Order1, [ 1(ascending order) or 2(descending order) ]<br />                key2,        // key2, <br />                VOptional,   // type, [xlSortLabels, xlSortValues]<br />                DeCrement2,  // long Order2, [ 1(升冪) or 2( 降) ]<br />                key3,        // key3<br />                DeCrement3,  // long Order3, [ 1(升冪) or 2( 降) ]<br />                2,           // Header, [0,1 : 不含 title 2 : title （選取範圍）一起排<br />          //進階<br />                VOptional,   // OrderCustom [從1開始，自定義排序順序列表中之索引號，省略使用常規]<br />                _variant_t((short)TRUE),    // MatchCase [TRUE分大小寫排]<br />                1,           // Orientation : [排序方向, 1:按列, 2:按行)<br />                1,           // SortMethod : [1:按字符漢語拼音順序, 2:按字符筆畫數]<br />       //未知選項<br />                1,           // DataOption1 可選 0 與 1<br />                1,           // DataOption2 可選 0 與 1<br />                1            // DataOption3 可選 0 與 1<br />    );</code></pre><h2><span style="font-size: x-large;">xlsFile.cpp</span></h2><h3><span style="font-size: large;">簡化初始化動作</span></h3>在細部操作裡，初始化設計實在是一件，不容易的事。<br />做太多，失去彈性，做太少，又增加函數之間的耦合力，容易讓人產生「誰知道要呼叫這個」的OS。在此，盡量設計的和Excel操作一樣，打開App這一步。而關掉也是設計對應的動作。<br />在construct有一個條件編譯的部份，是在debug模式中，盡快的顯示Excel，但是在release模式中，就把程式化的表格動作結束後，再顯示比較好。<br /><pre class="prettyprint"><code class="language-cpp">xlsFile::xlsFile(): <br />VOptional((long)DISP_E_PARAMNOTFOUND,VT_ERROR), VFALSE((short)FALSE), VTRUE((short)TRUE)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    //Step 1.叫Excel應用程式<br />    if(!objApp.CreateDispatch("Excel.Application",&amp;e))<br />    {<br />        CString str;<br />        str.Format("Excel CreateDispatch() failed w/err 0x%08lx", e.m_sc);<br />        AfxMessageBox(str, MB_SETFOREGROUND);<br />    }<br />#ifdef _DEBUG<br />    SetVisible(true);<br />#endif<br />};<br /><br />xlsFile::~xlsFile()<br />{<br />    range.ReleaseDispatch();<br />    objSheet.ReleaseDispatch();<br />    objSheets.ReleaseDispatch();<br />    objBook.ReleaseDispatch();<br />    objBooks.ReleaseDispatch();<br />    objApp.ReleaseDispatch();<br />}</code></pre><h3><span style="font-size: large;">維持 開新檔案/開啟舊檔/存檔/另存新檔 的整體概念</span></h3>概念描述<br /><pre class="prettyprint"><code class="language-cpp">xlsFile* xlsFile::New()<br />{<br />    objBooks = objApp.GetWorkbooks();<br />    objBook = objBooks.Add(VOptional);    //開新檔案<br />    objSheets = objBook.GetWorksheets();<br />    return this;<br />}<br /><br />xlsFile* xlsFile::Open(const char* path)<br />{<br />    objBooks = objApp.GetWorkbooks();<br />    objBook.AttachDispatch(objBooks.Add(_variant_t(path))); //開啟一個已存在的檔案<br />    objBook.Activate();<br />    objSheets = objBook.GetWorksheets();<br />    return this;<br />}<br /><br />void xlsFile::SaveAs(const char* strTableName)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf, "%s", strTableName);<br />    objBook.SaveAs(<br />        COleVariant(buf),<br />        VOptional, VOptional, <br />        VOptional, VOptional, <br />        VOptional, 1,<br />        VOptional, VFALSE,<br />        VOptional, VOptional, VOptional); <br />}<br /><br />void xlsFile::Save()<br />{<br />    objBook.Save();<br />}</code></pre><h3><span style="font-size: large;">畫出視窗</span></h3>就是把視窗畫出來，之後把控制權給使用者。<br /><pre class="prettyprint"><code class="language-cpp">//SetVisible()<br />void xlsFile::SetVisible(bool a)<br />{<br />    objApp.SetVisible(a);    //顯示Excel檔<br />    objApp.SetUserControl(a);//使用者控制後，就不可以自動關閉<br />}<br /></code></pre><h3><span style="font-size: large;">對Sheet的操作</span></h3>其中，在選擇sheet時，常常會出現，程式碼指定選擇一個不存在的sheet，這時出錯了，只有一個空白的MessageBox()，出現了也不知道出了什麼事？哪裡出了問題，所以就在SelectSheet()時做try-catch的設計<br /><pre class="prettyprint"><code class="language-cpp">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br />//Sheet操作<br /><br />//-------------------------<br />////取得 Sheet 個數<br />long xlsFile::SheetTotal()<br />{<br />    return objSheets.GetCount();//edisonx<br />}<br />//-------------------------<br />//由SheetIndex 指定SheetName<br />void xlsFile::SetSheetName(short SheetIndex, const char* SheetName)<br />{<br />    try<br />    {<br />        objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />        objSheet.SetName(SheetName);//設定sheet名稱<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("設定第%d個Sheet的名字為%s出錯了！", SheetIndex, SheetName);<br />        AfxMessageBox(str);<br />    }<br />}<br />//-------------------------<br />//由SheetIndex 取得SheetName<br />CString xlsFile::GetSheetName(short SheetIndex)<br />{<br />    try<br />    {<br />        objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("取得第%d個Sheet名字出錯了！", SheetIndex);<br />        AfxMessageBox(str);<br />    }<br />    return objSheet.GetName();//edisonx<br />}<br />//-------------------------<br />//選擇Sheet<br />//由SheetName<br />xlsFile* xlsFile::SelectSheet(const char* SheetName)<br />{<br />    try<br />    {<br />        objSheet = objSheets.GetItem(_variant_t(SheetName));<br />        objSheet.Activate();//edisonx<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("選擇Sheet: %s出錯了！", SheetName);<br />         AfxMessageBox(str);<br />    }<br />    return this;<br />}<br />//由SheetIndex <br />xlsFile* xlsFile::SelectSheet(short SheetIndex)<br />{<br />    try<br />    {<br />        objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />        objSheet.Activate();//edisonx<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("選擇第%d個Sheet出錯了！", SheetIndex);<br />        AfxMessageBox(str);<br />    }<br />    return this;<br />}<br />//-------------------------<br />//複製SheetName 指定插入Sheet的位置，並指定新Sheet名稱<br />void xlsFile::CopySheet(const char* SheetName)<br />{<br />    objSheet.AttachDispatch(objSheets.GetItem(_variant_t(SheetName)),true);<br />    objSheet.Copy(vtMissing,_variant_t(objSheet));<br />}<br />//複製SheetIndex 指定插入Sheet的位置，並指定名稱<br />void xlsFile::CopySheet(short SheetIndex)<br />{<br />    objSheet.AttachDispatch(objSheets.GetItem(COleVariant(SheetIndex)));<br />    objSheet.Copy(vtMissing,_variant_t(objSheet));<br />}<br />//-------------------------<br />//刪除Sheet<br />//選SheetName <br />void xlsFile::DelSheet(const char* SheetName)<br />{    <br />    objSheet = objSheets.GetItem(_variant_t(SheetName));<br />    objSheet.Delete();//edisonx<br />}<br />//選SheetIndex<br />void xlsFile::DelSheet(short SheetIndex)<br />{<br />    objSheet = objSheets.GetItem(COleVariant(SheetIndex));<br />    objSheet.Delete();//edisonx<br />}</code></pre><h3><span style="font-size: large;">對儲存格(Cell)的操作</span></h3>一般常見的cell操作，都在上面了<br /><pre class="prettyprint"><code class="language-cpp">///////////////////////////////////////////////////////////////////////////////////////////<br />//Cell操作<br />//Cell計數計算<br />// 取得起始列<br />long xlsFile::GetHorztlStartCell()<br />{<br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    return usedrange.GetColumn();<br />}<br />// 取得起始行<br />long xlsFile::GetVrticlStartCell()<br />{    <br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    return usedrange.GetRow();<br />}<br />// 取得總列數<br />long xlsFile::GetHorztlTotalCell()<br />{<br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    range.AttachDispatch(usedrange.GetColumns());<br />    return range.GetCount();<br />}<br />// 取得總行數<br />long xlsFile::GetVrticlTotalCell()<br />{<br />    Range usedrange;<br />    usedrange.AttachDispatch(objSheet.GetUsedRange());<br />    range.AttachDispatch(usedrange.GetRows());<br />    return range.GetCount();<br />}<br />//清除儲存格<br />void xlsFile::ClearCell()<br />{<br />    //先選取一個範圍的儲存格<br />    range.Clear();//edisonx<br />}<br />//合併儲存格<br />xlsFile* xlsFile::SetMergeCells(short vMerge, bool isCenterAcross)<br />{<br />    //先選取一個範圍的儲存格<br />    range.SetMergeCells(_variant_t(vMerge));<br />    if(isCenterAcross) SetHorztlAlgmet(HA_CENTERACROSS);<br />    return this;<br />}</code></pre><h3><span style="font-size: large;">選擇儲存格(Cell)</span></h3>選擇格子的動作，就像是用滑鼠點選儲存格一樣直覺，分成兩種，點選格子和點選範圍<br />其中，和選擇sheet一樣，若出現了選擇了超過Z的格子(用迴圈控制，就可能會超過Z)，就會出問題，也設計了try-catch來顯示出問題的格子在哪<br /><pre class="prettyprint"><code class="language-cpp">//-------------------------<br />//Cell格式設定<br />//-------------------------<br />//選格子<br />//選一格<br />xlsFile* xlsFile::SelectCell(const char* x)<br />{<br />    try<br />    {<br />        range=objSheet.GetRange(COleVariant(x),COleVariant(x));<br />        ASSERT(range);<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("選擇儲存格%s出錯了！", x);<br />        AfxMessageBox(str);<br />    }<br />    return this;<br />}<br /><br />xlsFile* xlsFile::SelectCell(const char* x, int y)<br />{<br />    try<br />    {<br />        ZeroMemory(buf,sizeof(buf));<br />        sprintf(buf,"%s%d",x,y);<br />        range=objSheet.GetRange(COleVariant(buf),COleVariant(buf));<br />        ASSERT(range);<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("選擇儲存格%s%d出錯了！", x, y);<br />        AfxMessageBox(str);<br />    }<br />    return this;<br />}<br />//小於Z<br />xlsFile* xlsFile::SelectCell(char x, int y)<br />{<br />    if (x &gt;= 'A' &amp;&amp; x &lt;= 'Z')<br />    {<br />        ZeroMemory(buf,sizeof(buf));<br />        sprintf(buf,"%c%d",x,y);<br />        range=objSheet.GetRange(COleVariant(buf),COleVariant(buf));<br />        ASSERT(range);<br />    }<br />    else<br />    {<br />        CString str;<br />        str.Format("選擇儲存格%c%d出錯了！", x, y);<br />        AfxMessageBox(str);<br />        ASSERT(x &gt;= 'A' &amp;&amp; x &lt;= 'Z');<br />    }<br />    return this;<br />}<br />//大於Z，開始選AA<br />xlsFile* xlsFile::SelectCell(char x1, char x2, int y)<br />{<br />    if ( (x1 &gt;= 'A' &amp;&amp; x1 &lt;= 'Z') &amp;&amp; (x2 &gt;= 'A' &amp;&amp; x2 &lt;= 'Z'))<br />    {<br />        ZeroMemory(buf,sizeof(buf));<br />        sprintf(buf,"%c%c%d",x1,x2,y);<br />        range=objSheet.GetRange(COleVariant(buf),COleVariant(buf));<br />        ASSERT(range);<br />    }<br />    else<br />    {<br />        CString str;<br />        str.Format("選擇儲存格%c%c%d出錯了！", x1, x2, y);<br />        AfxMessageBox(str);<br />        ASSERT(x1 &gt;= 'A' &amp;&amp; x1 &lt;= 'Z');<br />        ASSERT(x2 &gt;= 'A' &amp;&amp; x2 &lt;= 'Z');<br />    }<br />    return this;<br />}<br />//-------------------------<br />//選範圍<br />xlsFile* xlsFile::SelectCell(const char* x1, const char* x2)<br />{<br />    try<br />    {<br />        range=objSheet.GetRange(COleVariant(x1),COleVariant(x2));<br />        ASSERT(range);<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("選擇範圍，從%s到%s出錯了！", x1, x2);<br />        AfxMessageBox(str);<br />    }<br />    return this;<br />}<br /><br />xlsFile* xlsFile::SelectCell(const char* x1, int y1, const char* x2, int y2)<br />{<br />    try<br />    {<br />        ZeroMemory(buf1,sizeof(buf1));<br />        ZeroMemory(buf2,sizeof(buf2));<br />        sprintf(buf1,"%s%d",x1,y1);<br />        sprintf(buf2,"%s%d",x2,y2);<br />        range=objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />        ASSERT(range);<br />    }<br />    catch (...)<br />    {<br />        CString str;<br />        str.Format("選擇範圍，從%s%d到%s%d的地方出錯了！", x1, y1, x2, y2);<br />        AfxMessageBox(str);<br />    }<br />    return this;<br />}<br />//小於Z<br />xlsFile* xlsFile::SelectCell(char x1, int y1, char x2, int y2)<br />{<br />    if (x1 &gt;= 'A' &amp;&amp; x1 &lt;= 'Z')<br />    {<br />        ZeroMemory(buf1,sizeof(buf1));<br />        ZeroMemory(buf2,sizeof(buf2));<br />        sprintf(buf1,"%c%d",x1,y1);<br />        sprintf(buf2,"%c%d",x2,y2);<br />        range=objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />        ASSERT(range);<br />    }<br />    else<br />    {<br />        CString str;<br />        str.Format("選擇範圍，從%c%d到%c%d出錯了！", x1, y1, x2, y2);<br />        AfxMessageBox(str);<br />        ASSERT(x1 &gt;= 'A' &amp;&amp; x1 &lt;= 'Z');<br />    }<br />    return this;<br />}<br />//大於Z，開始選AA<br />xlsFile* xlsFile::SelectCell(char xA1, char xB1, int y1, char xA2, char xB2, int y2)<br />{<br />    if ( (xA1 &gt;= 'A' &amp;&amp; xA2 &lt;= 'Z') &amp;&amp; (xB1 &gt;= 'A' &amp;&amp; xB2 &lt;= 'Z') )<br />    {<br />        ZeroMemory(buf1,sizeof(buf1));<br />        ZeroMemory(buf2,sizeof(buf2));<br />        sprintf(buf1,"%c%c%d",xA1,xB1,y1);<br />        sprintf(buf2,"%c%c%d",xA2,xB2,y2);<br />        <br />        range=objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />        ASSERT(range);<br />    }<br />    else<br />    {<br />        CString str;<br />        str.Format("選擇範圍，從%c%c%d到%c%c%d出錯了！", xA1, xB1, y1, xA2, xB2, y2);<br />        AfxMessageBox(str);<br />        ASSERT(xA1 &gt;= 'A' &amp;&amp; xA2 &lt;= 'Z');<br />        ASSERT(xB1 &gt;= 'A' &amp;&amp; xB2 &lt;= 'Z');<br />    }<br />    return this;<br />}</code></pre><h3><span style="font-size: large;">靠左/靠右/靠上/靠下/置中 旋轉/文字自動換行</span></h3>保持與Excel操作介面相同的思考方式，其參數在.h檔中，有列舉成文字，不需使用數字做辨識，可提高可讀性。<br /><pre class="prettyprint"><code class="language-cpp">//-------------------------<br />//對齊方式<br />//水平對齊<br />xlsFile* xlsFile::SetHorztlAlgmet(short position)<br />{<br />    range.SetHorizontalAlignment(COleVariant(position));<br />    return this;<br />}<br />//垂直對齊<br />xlsFile* xlsFile::SetVrticlAlgmet(short position)<br />{<br />    range.SetVerticalAlignment(COleVariant(position));<br />    return this;<br />}<br />//對齊方式的方向幾度（+90~-90）<br />xlsFile* xlsFile::SetTextAngle(short Angle)<br />{<br />    range.SetOrientation(COleVariant(Angle)); <br />    return this;<br />}<br />//設定文字自動換行<br />xlsFile* xlsFile::AutoNewLine(bool NewLine)<br />{<br />    if(NewLine)    range.SetWrapText(VTRUE);<br />    else           range.SetWrapText(VFALSE);<br />    return this;<br />}</code></pre><h3><span style="font-size: large;">設定框線粗細、框線顏色</span></h3>用同一個介面來設定框線和框線顏色，對於造一個表格來說，是方便的事，若有需要，也可以將它拆開兩個各別處理。但是因為沒有遇到這樣的需求，所以就沒有設計這樣的介面。<br /><pre class="prettyprint"><code class="language-cpp">//設定框線粗細、框線顏色<br />xlsFile* xlsFile::SetCellBorder(long BoarderStyle, int BoarderWeight, long BoarderColor)<br />{<br />    range.BorderAround(_variant_t(BoarderStyle), BoarderWeight, BoarderColor,_variant_t((long)RGB(0,0,0)));<br />    return this;<br />}</code></pre><h3><span style="font-size: large;">自動欄寬、列高</span></h3>在Excel中，只要對著調整格線的地方點兩下，即可適動調整適當欄寬和列高。<br />Excel預設的介面，原本無法一個函數搞定，要先選取整排，再調整。包起來的設計，比較直覺。<br /><pre class="prettyprint"><code class="language-cpp">//設定欄寬列高<br />//自動調整列高<br />void xlsFile::AutoFitWidth()<br />{<br />    col = range.GetEntireColumn();    //選取某個範圍的一整排<br />    col.AutoFit();                    //自動調整一整排的欄寬<br />}<br />//自動調整欄寬<br />void xlsFile::AutoFitHight()<br />{<br />    row = range.GetEntireRow();        //選取某個範圍的一整排<br />    row.AutoFit();                    //自動調整一整排的列高<br />}<br />//設定列高<br />xlsFile* xlsFile::SetCellHeight(float height)<br />{<br />    range.SetRowHeight(_variant_t(height));<br />    return this;<br />}<br />//設定欄寬<br />xlsFile* xlsFile::SetCellWidth(float height)<br />{<br />    range.SetColumnWidth(_variant_t(height));<br />    return this;<br />}</code></pre><h3><span style="font-size: large;">儲存格字型的操作</span></h3>字型的顏色、粗體、字型大小...在工作列上的那一排常用的功能，都建上來了。<br />顏色對照，參考.....參考文件！XDDD <br /><pre class="prettyprint"><code class="language-cpp">//設定字型<br />xlsFile* xlsFile::SetFont(const char* fontType)<br />{<br />    font = range.GetFont();<br />    font.SetName(_variant_t(fontType));//原本是韓文字型<br />    return this;<br />}<br />//粗體<br />xlsFile* xlsFile::SetFontBold(bool isBold)<br />{<br />    font = range.GetFont();<br />    if (isBold)    font.SetBold(VTRUE);//粗體<br />    else           font.SetBold(VFALSE);<br />    return this;<br />}<br />//刪除線<br />xlsFile* xlsFile::SetFontStrkthrgh(bool isStrike)<br />{<br />    font = range.GetFont();<br />    if (isStrike)    font.SetStrikethrough(VTRUE);    //edisonx<br />    else             font.SetStrikethrough(VFALSE);    //edisonx<br />    return this;<br />}<br />//字型大小<br />xlsFile* xlsFile::SetFontSize(short fontSize)<br />{<br />    font = range.GetFont();<br />    font.SetSize(_variant_t(fontSize));//字型大小pt<br />    return this;<br />}<br />//字型顏色<br />xlsFile* xlsFile::SetFontColor(short colorIndex)<br />{<br />    font = range.GetFont();<br />    font.SetColorIndex(_variant_t(colorIndex)); //字色(預設黑色)<br />    return this;<br />}</code></pre><h3><span style="font-size: large;">填滿色彩</span></h3>在填滿色彩時，設計了使用座標的方式做操作，此是使用Excel視窗軟體介面上的調色盤的位置為準。<br />除此之外，還有快速選色介面，不過只有幾個純色支援此介面。<br /><pre class="prettyprint"><code class="language-cpp">//設定底色<br />xlsFile* xlsFile::SetCellColor(short colorIndex)<br />{<br />    cell = range.GetInterior();                   //取得選取範圍，設定儲存格的記憶體位址<br />    cell.SetColorIndex(_variant_t(colorIndex));   //設定底色（查表）<br />    //cell.SetColor(_variant_t(colorIndex));<br />    return this;<br />}<br />//選擇顏色（適合字色和底色）依excel介面的座標選擇顏色<br />short xlsFile::SelectColor(short x, short y)<br />{<br />//Microsoft Excel 的顏色排序是依<br />//紅、橙、黃、綠、藍、靛、紫、灰（y）<br />//由深到淺（x）<br />    switch(x)<br />    {<br />    case 1:<br />             if(y == 1) return 1;<br />        else if(y == 2) return 9;<br />        else if(y == 3) return 3;<br />        else if(y == 4) return 7;<br />        else if(y == 5) return 38;<br /><br />        else if(y == 6) return 17;<br />        else if(y == 7) return 38;<br />        break;<br />    case 2:<br />             if(y == 1) return 53;<br />        else if(y == 2) return 46;<br />        else if(y == 3) return 45;<br />        else if(y == 4) return 44;<br />        else if(y == 5) return 40;<br />        <br />        else if(y == 6) return 18;<br />        else if(y == 7) return 26;<br />        break;<br />    case 3:<br />             if(y == 1) return 52;<br />        else if(y == 2) return 12;<br />        else if(y == 3) return 43;<br />        else if(y == 4) return  6;<br />        else if(y == 5) return 36;<br />        <br />        else if(y == 6) return 19;<br />        else if(y == 7) return 27;<br />        break;<br />    case 4:<br />             if(y == 1) return 51;<br />        else if(y == 2) return 10;<br />        else if(y == 3) return 50;<br />        else if(y == 4) return  4;<br />        else if(y == 5) return 35;<br />        <br />        else if(y == 6) return 20;<br />        else if(y == 7) return 28;<br />        break;<br />    case 5:<br />             if(y == 1) return 49;<br />        else if(y == 2) return 14;<br />        else if(y == 3) return 42;<br />        else if(y == 4) return  8;<br />        else if(y == 5) return 34;<br />        <br />        else if(y == 6) return 21;<br />        else if(y == 7) return 29;<br />        break;<br />    case 6:<br />             if(y == 1) return 11;<br />        else if(y == 2) return  5;<br />        else if(y == 3) return 41;<br />        else if(y == 4) return 33;<br />        else if(y == 5) return 37;<br />        <br />        else if(y == 6) return 22;<br />        else if(y == 7) return 30;<br />        break;<br />    case 7:<br />             if(y == 1) return 55;<br />        else if(y == 2) return 47;<br />        else if(y == 3) return 13;<br />        else if(y == 4) return 54;<br />        else if(y == 5) return 39;<br />        <br />        else if(y == 6) return 23;<br />        else if(y == 7) return 31;<br />        break;<br />    case 8:<br />             if(y == 1) return 56;<br />        else if(y == 2) return 16;<br />        else if(y == 3) return 48;<br />        else if(y == 4) return 15;<br />        else if(y == 5) return  2;<br />        <br />        else if(y == 6) return 24;<br />        else if(y == 7) return 32;<br />        break;<br />    }<br />    return 2;//預設白色<br />}<br />short xlsFile::SelectColor(const char ColorChar)<br />{<br />    switch(ColorChar)<br />    {<br />    //黑色<br />    case 'D':<br />    case 'd':<br />        return 1;<br />        break;<br />    //白色<br />    case 'W':<br />    case 'w':<br />        return 2;<br />        break;<br />    //紅色<br />    case 'R':<br />    case 'r':<br />        return 3;<br />        break;<br />    //綠色<br />    case 'G':<br />    case 'g':<br />        return 4;<br />        break;<br />    //藍色<br />    case 'B':<br />    case 'b':<br />        return 5;<br />        break;<br />    //黃色<br />    case 'Y':<br />    case 'y':<br />        return 6;<br />        break;    }<br />    return 2;//預設白色<br />}</code></pre><h3><span style="font-size: large;">Cell填值</span></h3>支援格種常用的儲存格格式，但是不支援時間格式。使用上要小心<br /><pre class="prettyprint"><code class="language-cpp">//SetCell()<br />void xlsFile::SetCell(int Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,"%d",Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(long Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,"%d",Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(double Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,"%f",Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(const char* Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    strcpy(buf,Data);<br />    //sprintf(buf,"%s",Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(CString Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,"%s",Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(const char* Format, int Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,Format,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(const char* Format, double Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,Format,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br /><br />void xlsFile::SetCell(const char* Format, long Data)<br />{<br />    ZeroMemory(buf,sizeof(buf));<br />    sprintf(buf,Format,Data);<br />    range.SetItem(_variant_t((long)1),_variant_t((long)1),_variant_t(buf));<br />}<br />//-------------------------<br />CString xlsFile::GetCell2CStr()<br />{<br />    return (char*)_bstr_t(range.GetItem(_variant_t((long)1), _variant_t((long)1)));<br />}<br />int xlsFile::GetCell2Int()<br />{<br />    COleVariant vResult = range.GetValue2();   //edisonx <br />    vResult.ChangeType(VT_INT);                //edisonx <br />    return vResult.intVal;                     //edisonx <br />}<br />double xlsFile::GetCell2Double()<br />{<br />    COleVariant vResult = range.GetValue2();  //edisonx <br />    vResult.ChangeType(VT_R8);                //edisonx <br />    return vResult.dblVal;                    //edisonx <br />}</code></pre><h3><span style="font-size: large;">排序演算法</span></h3>排序演算法有分主要順序和次要順序的設定，可以順序填值，也可以填完值再排序。<br /><pre class="prettyprint"><code class="language-cpp">//排序<br />void xlsFile::Sort(CString IndexCell1, long DeCrement1, CString IndexCell2, long DeCrement2, CString IndexCell3, long DeCrement3)<br />{<br />    VARIANT key1, key2, key3;<br /><br />    V_VT(&amp;key1) = VT_DISPATCH;<br />    V_DISPATCH(&amp;key1)=objSheet.GetRange(COleVariant(IndexCell1),COleVariant(IndexCell1));<br /><br />    if(IndexCell2.IsEmpty())<br />    {<br />        range.Sort( key1, DeCrement1, VOptional, VOptional, 1, VOptional, 1, 2,//一般選項<br />                    VOptional, _variant_t((short)TRUE),//進階 <br />                    1, 1, 1, 1, 1);//未知選項//edisonx<br />    }<br />    else<br />    {<br />        V_VT(&amp;key2) = VT_DISPATCH;<br />        V_DISPATCH(&amp;key2)=objSheet.GetRange(COleVariant(IndexCell2),COleVariant(IndexCell2));<br />        <br />        if(IndexCell3.IsEmpty())<br />        {<br />            range.Sort( key1, DeCrement1, key2,    VOptional, DeCrement2, VOptional, 1, 2,<br />                        VOptional, _variant_t((short)TRUE),                                //進階 <br />                        1, 1, 1, 1, 1);                                                    //未知選項//edisonx<br />        }<br />        else<br />        {<br />            V_VT(&amp;key3) = VT_DISPATCH;<br />            V_DISPATCH(&amp;key3)=objSheet.GetRange(COleVariant(IndexCell3),COleVariant(IndexCell3));<br />            <br />            range.Sort( key1, DeCrement1, key2, VOptional, DeCrement2, key3, DeCrement3, 2, //一般選項<br />                        VOptional, _variant_t((short)TRUE),                                 //進階 <br />                        1, 1, 1, 1, 1);                                                     //未知選項//edisonx<br />        }<br />    }<br />}</code></pre><h3><span style="font-size: large;">其它</span></h3>在其它，就將不常用的圖表/圖的新增與設定的操作放在這。<br />這裡的設計就比較不費心思，使用上也許會有種種困擾。小心使用！<br /><pre class="prettyprint"><code class="language-cpp">void xlsFile::newChart()<br />{<br />    //在Sheet新增圖表<br />    lpDisp = objSheet.ChartObjects(VOptional);<br />    chartobjects.AttachDispatch(lpDisp);    <br />    chartobject = chartobjects.Add(<br />                                (float)range.GetLeft(  ).dblVal,<br />                                (float)range.GetTop(   ).dblVal, <br />                                (float)range.GetWidth( ).dblVal, <br />                                (float)range.GetHeight().dblVal  );    //圖表符合儲存格範圍的大小<br />    xlsChart.AttachDispatch(chartobject.GetChart());    //資料來源（範圍left, top預設為 比較Item和Group）<br />}<br />///////////////////////////////////////////////////////////////////////////////////////////<br />//圖表操作<br />//儲存圖表<br />//edisonx<br />void xlsFile::SaveChart(CString FullBmpPathName)<br />{<br />    xlsChart.Export(LPCTSTR(FullBmpPathName),VOptional,VOptional);<br />}<br />//選擇表格資料的範圍<br />xlsFile* xlsFile::SelectChartRange(const char* x1,const char* x2)<br />{<br />    newChart();<br /><br />    lpDisp = objSheet.GetRange(COleVariant(x1),COleVariant(x2));<br />    range.AttachDispatch(lpDisp);<br />    <br />    return this;<br />}<br /><br />xlsFile* xlsFile::SelectChartRange(const char* x1, int y1, const char* x2, int y2)<br />{<br />    newChart();    <br /><br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    sprintf(buf1,"%s%d",x1,y1);<br />    sprintf(buf2,"%s%d",x2,y2);<br /><br />    lpDisp = objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />    range.AttachDispatch(lpDisp);<br />    return this;<br />}<br />//小於Z<br />xlsFile* xlsFile::SelectChartRange(char x1, int y1, char x2, int y2)<br />{<br />    newChart();<br /><br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    //發現了這個問題，但是忘記了是不是故意這樣寫的！<br />    //是x1, y1; x2, y2?<br />    sprintf(buf1,"%c%d",x1,y2);<br />    sprintf(buf2,"%c%d",x1,y2);<br /><br />    lpDisp = objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />    range.AttachDispatch(lpDisp);<br />    return this;<br />}<br />//大於Z，開始選AA<br />xlsFile* xlsFile::SelectChartRange(char xA1, char xB1, int y1, char xA2, char xB2, int y2)<br />{<br />    newChart();<br />    ZeroMemory(buf1,sizeof(buf1));<br />    ZeroMemory(buf2,sizeof(buf2));<br />    sprintf(buf1,"%c%c%d",xA1,xB1,y1);<br />    sprintf(buf2,"%c%c%d",xA2,xB2,y2);    <br />    lpDisp = objSheet.GetRange(COleVariant(buf1),COleVariant(buf2));<br />    range.AttachDispatch(lpDisp);<br />    return this;<br />}<br />// 設定表格參數（預設會顯示立體直方圖）<br />xlsFile* xlsFile::SetChart(short XaxisByToporLeft, bool isLabelVisable, CString TitleString, CString XaxisTitle, CString YaxisTitle) <br />{    <br />    var.vt = VT_DISPATCH;<br />    var.pdispVal = lpDisp;<br /><br />    short LabelVisable(FALSE);<br />    LabelVisable = (isLabelVisable) ? (short)TRUE : (short)FALSE ;<br />        <br />    xlsChart.ChartWizard(<br />        var,                                   // const VARIANT&amp; Source.<br />        COleVariant((short)11),                // const VARIANT&amp; fix please, Gallery: 3d Column. 1 or 11 是否轉動3D（3D類適用, 1轉，11不轉）<br />        COleVariant((short)1),                 // const VARIANT&amp; fix please, Format, use default<br />        COleVariant(XaxisByToporLeft),         // const VARIANT&amp; PlotBy: 1.X  2.Y 圖表的x軸要使用 表格的1:X-top還是2:Y-left<br />        COleVariant((short)1),                 // const VARIANT&amp; Category Labels fix please 不當軸的那個資料，從第幾個格子開始算（比較群組資料數量）<br />        COleVariant((short)1),                 // const VARIANT&amp; Series Labels. Start X, 不當軸的那個資料，資料名稱要用幾排格子（更改名字）<br />        COleVariant(LabelVisable),             // const VARIANT&amp; HasLegend. 是否要顯示群組資料標籤<br />        //以下可不填<br />        _variant_t(COleVariant(TitleString)),  // const VARITNT&amp; Title<br />        _variant_t(COleVariant(XaxisTitle)),   // const VARIANT&amp; CategoryTitle<br />        _variant_t(COleVariant(YaxisTitle)),   // const VARIANT&amp; ValueTitle<br />        VOptional                              // const VARIANT&amp; ExtraTitle<br />        );<br />    return this;<br />}<br />//插入圖表<br />void xlsFile::InsertHistogramChart(int shapeType, bool is3D, <br />                                   int isVrticl_Horztl_Other, <br />                                   int isNone_Stack_Percent )<br />{<br />    long ChartType = 51;<br />    if (shapeType == 0)//Area<br />    {<br />        if(!is3D)   //2D<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = 1;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 77; //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 76; //有百分比<br />        }<br />        else        //3D<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = -4098; //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 78;    //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 79;    //百分比<br />        }<br />    } <br />    else if (shapeType == 1)//直方圖<br />    {<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        {<br />            if(!is3D)   //2D<br />            {<br />                     if (isNone_Stack_Percent == 0) ChartType = 51; //無堆疊<br />                else if (isNone_Stack_Percent == 1) ChartType = 52; //有堆疊<br />                else if (isNone_Stack_Percent == 2) ChartType = 53; //有百分比<br />            }<br />            else        //3D<br />            {<br />                     if (isNone_Stack_Percent == 0) ChartType = 54; //無堆疊<br />                else if (isNone_Stack_Percent == 1) ChartType = 55; //有堆疊<br />                else if (isNone_Stack_Percent == 2) ChartType = 56; //百分比<br />            }<br />        }<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        {<br />            if(!is3D)   //2D<br />            {<br />                     if (isNone_Stack_Percent == 0) ChartType = 57;<br />                else if (isNone_Stack_Percent == 1) ChartType = 58;<br />                else if (isNone_Stack_Percent == 2) ChartType = 59;<br />            }<br />            else        //3D<br />            {<br />                     if (isNone_Stack_Percent == 0) ChartType = 60;<br />                else if (isNone_Stack_Percent == 1) ChartType = 61;<br />                else if (isNone_Stack_Percent == 2) ChartType = 62;<br />            }<br />        }<br />        else                                        ChartType = -4100;    //平面 必3D<br />    }<br />    else if (shapeType == 2)//CONE<br />    {<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = 92;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 93;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 94;  //百分比<br />        }<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = 95;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 96;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 97;  //百分比<br />        }<br />        else                                    ChartType = 98;  //平面 必3D<br />    }<br />    else if (shapeType == 3)<br />    {<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType =  99;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 100;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 101;  //百分比<br />        }<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        {<br />                  if(isNone_Stack_Percent == 0) ChartType = 102;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 103;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 104;  //百分比<br />        }<br />        else                    ChartType = 105;//平面 必3D<br />    }<br />    else if (shapeType == 4)<br />    {<br />        if(isVrticl_Horztl_Other == 0)//直的<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = 106;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 107;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 108;  //百分比<br />        }<br />        else if(isVrticl_Horztl_Other == 1)//橫的<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = 109;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 110;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 111;  //百分比<br />        }<br />        else                                    ChartType = 112;  //平面 必3D<br />    }<br />    xlsChart.SetChartType((long)ChartType);<br />}<br />///////////////////////////////////////////////////////////////<br />//泡泡<br />void xlsFile::InsertBubleChart(bool is3D)<br />{<br />    long ChartType = 51;<br /><br />    if(is3D)    ChartType = 15;<br />    else        ChartType = 87;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />}<br />//圓環<br />void xlsFile::InsertDoughnutChart(bool Explode)<br />{<br />    long ChartType = 51;<br />    <br />    if(!Explode)    ChartType = -4120;<br />    else            ChartType = 80;<br /><br />    xlsChart.SetChartType((long)ChartType);<br /><br />}<br />//曲面<br />void xlsFile::InsertSurfaceChart(bool is3D, bool isWire)<br />{<br />    long ChartType = 51;<br />    <br />    if (is3D)<br />    {<br />        if (!isWire)    ChartType = 83;<br />        else            ChartType = 84;<br />    } <br />    else<br />    {<br />        if (!isWire)    ChartType = 85;<br />        else            ChartType = 86;<br />    }<br /><br />    xlsChart.SetChartType((long)ChartType);<br />}<br />//雷達<br />void xlsFile::InsertRadarChart(bool isWire, bool isDot)<br />{<br />    long ChartType = 51;<br />    <br />    if (isWire)<br />    {<br />        if (!isDot) ChartType = -4151;<br />        else        ChartType = 81;<br />    } <br />    else            ChartType = 82;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />}<br />//圓餅<br />void xlsFile::InsertPieChart(bool Explode, int type2Dor3DorOf)<br />{<br />    long ChartType = 51;<br /><br />    if(!Explode)<br />    {<br />             if (type2Dor3DorOf == 0)        ChartType = 5;<br />        else if (type2Dor3DorOf == 1)        ChartType = -1402;<br />        else if (type2Dor3DorOf == 2)        ChartType = 68;<br />    }<br />    else<br />    {<br />             if (type2Dor3DorOf == 0)        ChartType = 69;<br />        else if (type2Dor3DorOf == 1)        ChartType = 70;<br />        else if (type2Dor3DorOf == 2)        ChartType = 71;<br />    }<br />    <br />    xlsChart.SetChartType(ChartType);<br />}<br /><br />void xlsFile::InsertLineChart(bool isDot, bool is3D, int isNone_Stack_Percent)<br />{<br />    long ChartType = 51;<br />    <br />    if(!is3D)//3D<br />    {<br />        if(!isDot)<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType =  4;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 63;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 64;  //有百分比<br />        }<br />        else<br />        {<br />                 if (isNone_Stack_Percent == 0) ChartType = 65;  //無堆疊<br />            else if (isNone_Stack_Percent == 1) ChartType = 66;  //有堆疊<br />            else if (isNone_Stack_Percent == 2) ChartType = 67;  //有百分比<br />        }<br />    }<br />    else                                        ChartType = -4101;  //3D<br /><br />    xlsChart.SetChartType((long)ChartType);<br />}<br />//離散圖<br />void xlsFile::InsertXYScatterChart(bool isDot, bool isLine, bool Smooth)<br />{<br />    long ChartType = 51;<br />    if(!isLine)          ChartType = -4169;  //3D<br />    else<br />    {<br />        if(Smooth)<br />        {<br />            if(isDot)    ChartType = 72;<br />            else         ChartType = 73;<br />        }<br />        else<br />        {<br />            if(isDot)    ChartType = 74;<br />            else         ChartType = 75;<br />        }<br />    }<br />    xlsChart.SetChartType((long)ChartType);<br />}<br /><br />//股票圖<br />void xlsFile::InsertStockChart(int StockType)<br />{<br />    long ChartType = 51;<br />    <br />         if (StockType == 0)    ChartType = 88;<br />    else if (StockType == 1)    ChartType = 89;<br />    else if (StockType == 2)    ChartType = 90;<br />    else if (StockType == 3)    ChartType = 91;<br /><br />    xlsChart.SetChartType((long)ChartType);<br />}<br />//--------------------------------------------<br />//--------------------------------------------<br />//插入圖（從檔案）<br />void xlsFile::InsertImage(const char* FileNamePath, float Width, float Height)<br />{<br />    shapes = objSheet.GetShapes(); <br />    shapes.AddPicture(<br />        FileNamePath,                   //LPCTSTR Filename<br />        false,                          //long LinkToFile<br />        true,                           //long SaveWithDocument<br />        (float)range.GetLeft().dblVal,  //float Left<br />        (float)range.GetTop().dblVal,   //float Top<br />        Width,                          //float Width<br />        Height                          //float Height<br />    );<br />}<br /><br />void xlsFile::InsertImage(const char* FileNamePath)<br />{<br />    shapes = objSheet.GetShapes(); <br />    shapes.AddPicture(<br />        FileNamePath,                   //LPCTSTR Filename<br />        false,                          //long LinkToFile<br />        true,                           //long SaveWithDocument<br />        (float)range.GetLeft().dblVal,  //float Left<br />        (float)range.GetTop().dblVal,   //float Top<br />        (float)range.GetWidth().dblVal, //float Width<br />        (float)range.GetHeight().dblVal //float Height<br />    );<br />}</code></pre>
