---
title: "c++的interface"
date: 2014-03-05T11:54:00.001+08:00
tags: 
- "C_and_Cpp"
categories:
- 舊部落格移植文章
---

# c++的interface

原文連結: https://darkblack01.blogspot.com/2014/03/cinterface.html
移植時的最後更新日期: 2015-12-23T14:16:57.629+08:00

最近和朋友一起看Design Pattern的書，選定的書本，是使用C#來實作。<br />而C#又是一種學java的語言，有interface這種C++沒有的東西。<br />心中浮現了一個問題，在C++中，要怎麼表達，才會最最最最貼切interface呢？？<br />不知道有在使用C++的朋友怎麼做呢？<br /><br />在此，我介紹一下我自己的想法。<br /><br />先來看看一個例子(c#)<br /><pre class="prettyprint"><code>interface ICloneable<br />{<br />    Object^ Clone();<br />}</code></pre>有幾個使用interface上的規則要注意：<br /><ol><li>要被繼承，不可以自己成為物件</li><li>繼承後要實作interface裡的function</li><li>function權限預設公開</li></ol>常見的C++實作，都是使用像下面這樣的做法滿足[1]<br /><pre class="prettyprint"><code>class ICloneable<br />{<br />public:<br />    Object* Clone() = 0;<br />}</code></pre>利用純虛擬的特性，強迫「被繼承」以及「衍生類別必實作其function」。<br />但是，使用C#與java的朋友知道，虛擬類別與interface的差別在於<br /><br />interface就是預計被繼承的member&nbsp;function介面集合(繼承介面的衍生類別，一定要實作該介面的member function。)interface沒有member var。<br /><br />嗯~~回過頭看看C++的實作，似乎滿足上面的樣子，但是總是無法區分純虛擬與interface，那怎麼辦呢？<br /><br />再回去看看上面interface的規則要注意的三點，其第三點，我們尚未滿足。<br /><br />看到這，你可能會問「怎麼會？我們有加 public: 呀！不就公開其權限了？？」<br /><br />嘖嘖嘖，會這樣反駁者，一定沒有仔細看描述<br /><br />&nbsp; &nbsp;3. function權限<span style="color: #cc0000;">預設</span>公開<br /><br />看到這，心裡應該有底了吧？<br />我們來實作看看，什麼叫做預設公開的....interface<br /><pre class="prettyprint"><code>struct ICloneable<br />{<br />    Object* Clone() = 0;<br />}</code></pre>發現了嗎？我們利用了struct的特性，讓它裡面只裝虛擬函式。這樣就和純虛擬類別區分開來了，並且預設公開。一般struct的用法是不放function，但是事實上，用法和class一模一樣，並沒有太多限制，所以可以這樣使用達到既與一般的struct不同，也和純虛擬函數不同，來達到interface的作用。<br /><br />最後，如果真的要實實在在的實作出一模一樣的程式，也不是不可能的，最後一個例子，就給程式碼語法狂熱愛好者看看，這樣做就可以滿足程式碼的美感與力度。<br /><pre class="prettyprint"><code>typedef struct interface<br />interface ICloneable<br />{<br />    Object* Clone() = 0;<br />}</code></pre><br />追求程式碼表現的美，還真的需要一點狂熱！哈哈~~<br /><br />參考資料：<br />[1]  <a href="http://scriptjerks.blogspot.tw/2012/06/c.html">[C++][筆記]介面實作</a>
