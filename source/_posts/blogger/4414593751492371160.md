---
title: Circle::Animation();的做法
date: 2013-02-26T11:44:00.002+08:00
tags: 
- WIN32 API/MFC

categories:
- 舊部落格移植文章
---

# Circle::Animation();的做法

原文連結: https://darkblack01.blogspot.com/2013/02/circleanimation.html
移植時的最後更新日期: 2013-04-11T00:20:50.739+08:00

在CPatternDlg中，宣告了一個圈圈物件<br /><pre class="prettyprint"><code>class CPatternDlg : public CDialog<br />{<br />    Circle m_Goal;<br />};</code></pre>因為想要圈圈做動畫，並且用下面的呼叫方式（漂亮的語法）<br /><pre class="prettyprint"><code>void CPatternDlg::readyScreen()<br />{<br />//...<br />    m_Goal.Animation();<br />}</code></pre>注意事項：<br />在此的動畫實作，是另外呼叫一個Thread來跑動畫程式段。<br /><br /><a name='more'></a><br /><h3><span style="font-size: large;">原本的做法</span></h3><pre class="prettyprint"><code>UINT CPatternDlg::vbrGoalThread(LPVOID LParam)<br />{<br />//...<br />    for (int i = 0; i &lt; 100; ++i)<br />    {        <br />         PtnDlg-&gt;InvalidateRect(pGoal-&gt;VbrFun(i, oriR));<br />         PtnDlg-&gt;UpdateWindow();<br />    }<br />}</code></pre>pGoal-&gt;VbrFun(i, oriR) 為動畫的數學式子（自已決定）<br />InvalidateRect();和UpdateWindow();為更新視窗的函數。<br /><br />使用<br /><pre class="prettyprint"><code>void CPatternDlg::readyScreen()<br />{<br />//...<br />    vbrGoalThread((LPVOID)&amp;Info1);<br />}</code></pre>在準備畫面時，執行這個函數，就會出現動畫。<br /><br /><br /><span style="color: #cc0000;">難點：</span><br /><span style="color: #cc0000;">動畫需要更新畫面，所以動畫的每一頁</span><span style="color: #cc0000;">的</span><span style="color: #cc0000;">更新步驟會建在CPattern::Animation()</span><br /><span style="color: #cc0000;">但若做成CPattern::Animation(Circle&amp; )，就違反概念整體性，也不OO了</span><br /><br /><h3><span style="font-size: large;">後來的做法</span></h3>我們來看看，先將動畫函數建在Circle<br /><pre class="prettyprint"><code>class Circle<br />{<br />private:<br />    CWnd* m_pdlgcWnd;<br />    static void elasticAnimation(LPVOID LParam);  //開新的Thread<br /><br />public:<br />    CWnd* gethWnd(){ return m_pdlgcWnd; };<br />     void setWnd(CWnd* cWnd){ m_pdlgcWnd = cWnd; };<br /><br />     void Animation(){ elasticAnimation((LPVOID)&amp;m_Info1); };<br />};</code></pre>在CPattern::CPattern()完成後，再用另一個函數將CWnd*存進Circle，為了畫面更新控制權。 <br /><pre class="prettyprint"><code>void CPatternDlg::SomeFunction()<br />{<br />//...<br />    m_Goal.setWnd(GetActiveWindow()); //GetActiveWindow()需等建構式完成才可以抓取<br />}</code></pre>最後在Circle裡建Animation()，再將「開新的Thread」函數隱藏起來 <br /><pre class="prettyprint"><code>void Circle::elasticAnimation(LPVOID LParam)<br />{<br />//...<br />    for (UINT i = 0; i &lt; 100; ++i)<br />    {<br />        _pCircle-&gt;gethWnd()-&gt;InvalidateRect(&amp;_pCircle-&gt;DampingVibration(i,  _pCircle-&gt;GetRadius()), TRUE);<br />        _pCircle-&gt;gethWnd()-&gt;UpdateWindow();<br />    }<br />}</code></pre>
