---
title: K&R2心得//型別、運算符號、運算式
date: 2011-03-21T08:49:00.000+08:00
tags: 
- C_and_Cpp
,- KnR2

categories:
- 舊部落格移植文章
---

# K&R2心得//型別、運算符號、運算式

原文連結: https://darkblack01.blogspot.com/2011/03/k_20.html
移植時的最後更新日期: 2015-12-23T14:16:57.737+08:00

<strong>翻譯問題</strong><br />字串→字串常數<br />字元→字符常數、字元常數<br />動態變數→自動型變數（非自動型的變數前面有加static）<br />資料型態（Type）→型別<br />P.2-14 &nbsp;求得一個值，代表s[i]的字元→將求得在s[i]中之字符的數值<br /><br /><a name='more'></a><br /><br /><br /><strong>P.2-2</strong><br />變數名稱<br />1. 字母開頭<br />&nbsp;&nbsp; &nbsp;_(underline)視為字母<br />&nbsp;&nbsp; &nbsp;用_為變數開頭，標準函式庫常用，使用者少用<br />2. 大小寫視為不同<br />3. 習慣上變數用小寫，而符號常數則用大寫<br />4. C語言至少可認識名稱的前31字符（不過還是因編譯器而異）<br />&nbsp;&nbsp; &nbsp;函數名稱、外部變數名稱，因會被載入程式（loader）或組譯（assembler），能辨識的可能更短。（外部名稱只能保証前6個字符有效）<br />5. 內定關鍵字（小寫）不可用。<br /><br /><strong>P.2-9</strong><br /><span style="color: blue;">enum boolean{ NO, YES };</span><br />意思是<br /><span style="color: blue;">#define NO 0<br />#define YES 1</span><br />在此enum可以依序（預設初值為0）遞增，並且可以指定第一個定義為什麼值<br /><span style="color: blue;">enum month{ JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };</span><br />意思是<br /><span style="color: blue;">#define JAN 1 <span style="color: #007f40;">//在此為1開始往後遞增</span><br /><span style="color: blue;">#define FEB 2<br />#define MAR 3</span></span><span style="color: blue;"><br />&nbsp;&nbsp; &nbsp;...<br />#define DEC 12</span><br />（不過不確定enmu是不是有宣告出記憶體，還是單純的替換文字而已）<br /><br /><strong>P.2-8</strong><br />靜態變數和外部變數，預設初值為0<br />一般變數（automatic）則無預設初值<br />const和static<br /><br />算術運算：加（+）、減（-）、乘（*）、除商（/）、除餘數（%）、正號（+）、負號（-）<br />關係運算：大於（&gt;）、大於等於（&gt;=）、小於（&lt;）、小於等於（&lt;=）<br />邏輯運算：交集（&amp;&amp;）、聯集（||）、否定（!）<br />遞增、遞減運算：遞增（++）、遞減（--）（i++)<br />位元運算：and（&amp;）、or（|）、xor（^）、左移（&lt;&lt;）、右移（&gt;&gt;）、not（~）<br /><br /><strong>算術運算：</strong><br /><strong>P.2-11</strong><br />%不可用於float和double型態。<br />overflow：數字太大，位元無法容納，切掉了。<br />underflow：數字太小，位元解析度不足，忽略掉當作0了。<br /><br /><strong>關係運算、邏輯運算</strong><br />就是結果為0或1的運算<br /><br /><strong>遞增、遞減運算</strong><br /><span style="color: blue;">x = n++;</span><br />就是<br /><span style="color: blue;">x = n;<br />n = n+1;</span><br /><span style="color: blue;"><br />x = ++n;</span><br />就是<br /><span style="color: blue;">n = n+1;<br />x = n;</span><br /><br /><span style="color: red;">不過n++和++n本身一樣，並沒有任何差別，差別只在於有等號出現時，先執行哪一個。</span><br /><br /><strong>位元運算</strong><br />AND（&amp;）設定某些位元為1，可稱為「位元遮罩」<br />OR（|）設定某些位元為1<br />XOR（^）設定相對應位元不同值時為1<br />左移（&lt;&lt;）一定補0（無論是否為有號數還是無號數）<br />右移（&gt;&gt;）unsigned的值在右移一定補0<br />signed不一定，看編譯器<br />NOT（~）多bit數取相反值（1的補數）（與<span style="color: red;">!</span>不一樣，!是<span style="color: red;">限定1bit取相反值</span>）<br /><br />之後是算式改寫，目的：<span style="color: red;">提高效率</span><br /><strong>設定運算式：</strong><br /><span style="color: blue;">a = a + b ; → a += b ;<br />a = a - b ; → a -= b ;<br />a = a * b ; → a *= b ;<br />a = a / b ; → a /= b ;<br />a = a % b ; → a %= b ;</span><br /><br /><strong>條件運算式：</strong><br /><span style="color: blue;">if ( a &gt; b )<br />&nbsp;&nbsp; &nbsp;z = a ;<br />else<br />&nbsp;&nbsp; &nbsp;z = b ;<br />&nbsp;&nbsp; &nbsp;↓<br /><span style="color: blue;">z = &nbsp;( a &gt; b ) ? a : b ;</span></span><br /><br /><strong>P.2-30</strong><br /><span style="color: red;">寫一個結果會取決於計算次序的程式是不好的習慣。</span><br /><span style="color: red;">簡化語法的同時也要避免這問題。</span>
