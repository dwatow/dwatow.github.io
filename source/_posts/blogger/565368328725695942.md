---
title: Code Complete II《軟體建構之道 2》#8 讀書心得與整理
date: 2013-02-07T14:28:00.000+08:00
tags: 
- Code Complete 2

categories:
- 舊部落格移植文章
---

# Code Complete II《軟體建構之道 2》#8 讀書心得與整理

原文連結: https://darkblack01.blogspot.com/2013/02/code-complate-ii-28.html
移植時的最後更新日期: 2013-02-08T11:01:41.930+08:00

<h2><span style="font-size: x-large;">第八章 防禦性程式設計<br />Defensive Programming</span></h2>開車有防衛駕駛，寫程式有防禦性程式設計<br /><br /><br /><h3><span style="font-size: large;">8.1 保護程式在無效輸入資料的破壞<br />Protecting Your Program from Invalid Inputs</span></h3><br />優秀的程式，無輪輸入什麼內容，都不會輸出垃圾。<br /><br />a. 檢查所有來自外部的常式的參數<br />b. 檢查所有來自其它常式的常式的參數→8.5<br />c. 決定如何處理錯誤的輸入→5.3<br /><br />最優秀的防禦性程式撰寫 <br /><ol><li>重複的設計</li><li>程式碼前先寫虛擬碼</li><li>程式碼前先寫測試案例</li><li>進行低層級設計視察</li></ol><br /><a name='more'></a><br /><br /><br /><br /><br /><h3><span style="font-size: large;">8.2 判斷提示<br />Assertions</span></h3><pre class="prettyprint"><code>assert(常式); &nbsp;//若常式為false，則程式崩潰、印出訊息。</code></pre>用來檢查假設 <br /><ol><li>是否滿足定義域和值域</li><li>檔案或資料流狀態是否開啟（或關閉）</li><li>檔案或資料流讀寫位置是否在開頭（或結尾）</li><li>檢查檔案或資料流權限（唯讀、唯寫、可讀寫）。</li><li>只能輸入的變數，經過一個常式是否有被改變</li><li>指標是否為null</li><li>陣列項目數量是否為特定數目</li><li>初始化的表格，變數是否都初始化了。</li><li>在常式內的容器，是否為空（或滿）</li><li>最佳化前後的常式，結果是否一致</li><li>....（更多更多的假設）</li></ol><br /><br /><h4>建立自己的Assertion機制<br />Building Your Own Assertion Mechanism</h4><br />標準的C++不提供文字訊息<br />所以，可以改寫成適合自己使用的ASSERT() <br /><pre class="prettyprint"><code>//C++ Example of a Assertion Macro<br />#define Assert( condition, message )\<br />{\<br />  if ( !(condition) )\<br />  {\<br />    LogError ("Assertion failed: ", #condition, message);\<br />    exit( EXIT_FAILURE );\<br />  }\<br />}</code></pre><h4>使用Assertions的方針<br />Guidelines for Using Assertions</h4><table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;" x:str=""> <colgroup><col style="mso-width-alt: 3552; mso-width-source: userset;"></col> <col style="mso-width-alt: 6944; mso-width-source: userset;"></col> <col style="mso-width-alt: 6240; mso-width-source: userset;"></col> </colgroup><tbody><tr>  <td class="xl22">　</td>  <td class="xl23" style="border-left: none;">處理錯誤的程式碼</td>  <td class="xl23" style="border-left: none;">Assert（判斷提示）</td> </tr><tr>  <td class="xl22" style="border-top: none;">處理什麼狀況</td>  <td class="xl23" style="border-left: none; border-top: none;">預期會發生</td>  <td class="xl23" style="border-left: none; border-top: none;">永遠不應發生</td> </tr><tr>  <td class="xl22" style="border-top: none;">檢查什麼</td>  <td class="xl23" style="border-left: none; border-top: none;">鮮少發生的非一般情況</td>  <td class="xl23" style="border-left: none; border-top: none;">永遠不應發生</td> </tr><tr>  <td class="xl22" style="border-top: none;">用來檢查</td>  <td class="xl23" style="border-left: none; border-top: none;">檢查錯誤的輸入資料</td>  <td class="xl23" style="border-left: none; border-top: none;">檢查程式碼中的bug</td> </tr></tbody></table>異常情況→用處理錯誤的程式碼→從容的做出反映<br />異常情況→用Assert()→重新編譯程式碼<br /><br /><b>Assert()中，不可以放置發佈版本會執行的程式碼。</b><br /><pre class="prettyprint"><code>//系統預設的code，assert本身並不會在release編譯時成為release版的程式內容<br />#ifdef _DEBUG<br />    ASSERT()<br />#endif</code></pre><b>用Assert()來驗證前置條件和後置條件</b><br /><br />檢查輸入 - 前置條件<br />檢查輸出 - 後置條件<br /><br />錯誤： <br /><ol><li>可靠的內部來源，檢查定義域外的值←用Assert(定義域)</li><li>外部來源，檢查錯誤格式←錯誤處理的程式碼</li></ol><b>對強壯的程式碼，應先使用Assert再處理錯誤</b><br /><br />常式通常會用 <br /><ol><li>Assert()</li><li>處理錯誤的程式碼</li></ol>通常不會兩個都用，但是若專案很大，人很多，時間很長，則建議兩個都用。<br />外部輸入 無法預測，也建議使用。<br /><br />debug版，兩者都有。<br />release版，剩下錯誤處理程式碼。  <br /><pre class="prettyprint"><code class="lang-vb">Visual Basic Example of Using Assertion to Document Preconditions and Postconditions<br />private Function Velocity ( _<br />    ByRef latitude As Single, _<br />    ByRef longitude  As Single, _<br />    ByRef elevation  As Single, _<br />) As Single<br /><br />' Preconditions'<br /><br />Debug.Assert( -90&lt;= latitude And latitude &lt;= 90 )<br />Debug.Assert( ...)<br />Debug.Assert( ...)<br />...<br />' Sanitize input data. Values should be within the ranges asserted above,'<br />' but if a value is not within its valid range, it will be changed to the closest legal value'<br />If  ( latitude &lt; -90 ) Then<br />     latitude = -90<br />ElseIf ( latitude &gt; 90 ) then<br />    latitude = 90<br />...<br /></code></pre><br /><br /><h3><span style="font-size: large;">8.3 錯誤處理技巧<br />Error-Handling Techniques</span></h3>Assert()可用來處理程式中永遠不該發生的錯誤。<br />那預期發生的錯誤呢？<br /><br /><b>1. 傳回中性的值</b><br />&nbsp; &nbsp; 若程式對於「呈現錯誤資料」的容許度很低，就別考慮這個方式了。<br /><br /><b>2. 以下一個有效值取代</b><br /><b>3. 以上一個有效值取代</b><br /><b>4. 以最接近的有效值取代</b><br /><br /><b>5. 將警告訊息記錄至檔案</b><br />&nbsp; &nbsp; 要考慮檔案的安全性、公開性的容許程度。<br /><br /><b>6. 回傳Error code</b><br />&nbsp; &nbsp; 「處理錯誤」和「反映錯誤」的副程式（或物件）區分清楚。<br />&nbsp; &nbsp; 低層級的程式碼：反映錯誤<br />&nbsp; &nbsp; 高層級的程式碼：處理錯誤<br /><br />&nbsp; &nbsp; 通知系統錯誤的（東西），會下列其中一種 <br /><ol><li>&nbsp; &nbsp; 設定狀態變數的值</li><li>&nbsp; &nbsp; 將狀態回傳，作為常式的回傳值</li><li>&nbsp; &nbsp; 用程式語言內嵌的例外處理</li></ol>這種情況之下，與「報告錯誤」的機制相比，「決定系統哪些部份要直接處理錯誤，哪些部份只是報告發生的錯誤」比較重要。<br /><br /><b>7. 呼叫錯誤處理常式或物件</b><br />&nbsp; &nbsp; 設計「集中處理錯誤」的常式或物件。<br />&nbsp; &nbsp; 不使用此方法，會是基於安全性的考量。<br /><br /><b>8. 顯示錯誤訊息</b><br />&nbsp; &nbsp; 處理錯誤的資源，將會在此方法減到最少。<br />&nbsp; &nbsp; 難以進行UI一致性和當地語系化。<br />&nbsp; &nbsp; 可能會受到「錯誤訊息探索」的方法攻擊系統。<br /><br /><b>9. 在常式內以最僅方法處理錯誤</b><br />&nbsp; &nbsp; 錯理錯誤的特定方式由程式設計人員決定。<br />&nbsp; &nbsp; 無法滿足「正確性」或「強壯性」的需求。<br />&nbsp; &nbsp; 四處都要寫入「使用者介面程式碼」<br /><br /><b>10. 關機</b><br />&nbsp; &nbsp; &nbsp; 對於特續開機會造成失控的風險，考慮關機是不錯的選擇。<br />（詳情可參考絕命終結站XDD）<br /><br /><h4>比較強壯性與正確性<br />Robustness vs. Correctness</h4><br />定義：<br />正確性(Correctness)：永遠不回傳不正確的結果<br />強壯性(Robustness)：永遠嘗試讓軟體能繼續操作<br /><br />考量：<br />人身安全相關軟體 &nbsp;正確性&gt;強壯性<br />消費性應用軟體 &nbsp; &nbsp;強壯性&gt;正確性<br /><br /><h4>高層次設計的錯誤處理啟示<br />High-Level Design Implications of Error Processing</h4><br />錯誤處理的方式，是由「架構上」和「高層次設計時」決定。<br />錯誤處理必須一致。錯誤務必處理，不可忽視。<br /><br />ex:<br />高階處理錯誤<br />低階報告錯誤（回傳Error code）<br /><br /><br /><h3><span style="font-size: large;">8.4 例外狀況<br />Exceptions</span></h3><br />例外狀況是一種特定的方法。<br /><br />常見語言支援情況<br /><table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;" x:str=""> <colgroup><col style="mso-width-alt: 4896; mso-width-source: userset;"></col> <col style="mso-width-alt: 6080; mso-width-source: userset;"></col> <col style="mso-width-alt: 11680; mso-width-source: userset;"></col> <col style="mso-width-alt: 5792; mso-width-source: userset;"></col> </colgroup><tbody><tr>  <td class="xl22">例外狀況屬性</td>  <td class="xl22" style="border-left: none;">C++</td>  <td class="xl22" style="border-left: none;">Java</td>  <td class="xl22" style="border-left: none;">Visual Basic</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">支援try-catch</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">支援try-catch-finally</td>  <td class="xl23" style="border-left: none; border-top: none;">無</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td>  <td class="xl23" style="border-left: none; border-top: none;">有</td> </tr><tr>  <td class="xl23" style="border-top: none;">可throw出什麼</td>  <td class="xl23" style="border-left: none; border-top: none;">Execption及其衍生物件。<br />物件指標、物件參照<br />資料型別（ex: char*, int)</td>  <td class="xl23" style="border-left: none; border-top: none;">Execption及其衍生物件</td>  <td class="xl23" style="border-left: none; border-top: none;">Execption及其衍生物件</td> </tr><tr>  <td class="xl23" style="border-top: none;">未攔截的例外狀況時的預設處理方式</td>  <td class="xl23" style="border-left: none; border-top: none;">呼叫std::unex   pected()<br />再預設呼叫std::terminate()<br />再預設呼叫abort()</td>  <td class="xl23" style="border-left: none; border-top: none;">終止執行緒。</td>  <td class="xl23" style="border-left: none; border-top: none;">終止程式</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">必須在類別介面中定義throw出的例外狀況</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td>  <td class="xl23" style="border-left: none; border-top: none;">是</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td> </tr><tr style="mso-height-source: userset;">  <td class="xl23" style="border-top: none;">必須在類別介面中定義catch到的例外狀況</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td>  <td class="xl23" style="border-left: none; border-top: none;">是</td>  <td class="xl23" style="border-left: none; border-top: none;">否</td> </tr></tbody></table><br /><b>用例外狀況通知其程式</b><br />例外狀況最大的好處，就是它能以無法忽略的方式，表示錯誤條件<br /><b>只在需要在真的例外狀況拋出throw</b><br />例外狀況只有Exception的try-catch可以處理，別的程式語法是無法取代的，而作用和assert()一樣，不只是處理罕見發生的事件，也處理永遠不應該發生的事。<br /><b>請勿將例外狀況來推卸責任</b><br />如果子程式可以在local程式碼處理例外狀況，請不要在這樣的程式碼throw出Exception，請在這個local程式碼處理掉。<br /><b>非在建構和解構式中攔截例外狀況，否則請避免在同樣位置中產生例外狀況</b><br />在建構式中發生Exception，那麼解構式中會變得複雜許多，否則就會在尚未建構的物件中解構，讓程式出現問題。<br />而在建構式和解構式中的Exception也會變得很複雜。<br /><b>以正確的抽象層產生例外狀況</b><br />維護概念整體性<br /><b>在例外狀況訊息內包含造成例外狀況的所有資訊</b><br />足夠多的訊息可以幫助閱讀的人了解情況。<br /><b>避免空的catch區塊</b><br /><pre class="prettyprint"><code>Bad Java Example of Ignoring an Exception<br />try{<br />    ...<br />    //lots of cods<br />    ...<br />} catch( AnException exception) {<br />    //程式執行到這，不會終止，會當作沒有這個例外而繼續執行。<br />    //可以的話寫個MessageBox或者記錄到檔案中也好。<br />    //空白的話讓co-work的程式設計不知道這是怎麼一回事<br />}</code></pre><b>了解程式庫程式碼所產生的例外狀況</b><br />程式庫(.dll檔)的Exception務必要全盤了解。<br /><b>考慮建立集中的例外狀況報告程式</b><br />報告成文件或顯示訊息，請統一報告的格式。<br /><b>標準化專案例外狀況的使用</b><br /><ul><li>用Exctption類別裝例外狀況拋出的所有物件。增加使用不同程式碼之間的相容性。</li><li>for專案的個人化Exception</li><li>定義在特定的情況中，程式碼可用throw-catch語法處理。</li><li>定義在特定的情況中，程式碼可用throw一個不在local程式碼中處理的exception&nbsp;。</li><li>決定是否使用集中的例外狀況報告格式</li><li>定義在構建式與解構式中，是否存在例外狀況。</li></ul><b>考慮例外 狀況的替代方法</b><br /><ul><li>區域程式處理錯誤</li><li>使用error code傳播錯誤</li><li>錯誤記錄到檔案中</li><li>關閉系統</li><li>其它</li></ul><span style="color: #cc0000;">記住要將程式「設計成語言&nbsp;(programming into a language)」，而不要掉進了「用語言」設計程式(programming in a language)。</span><br /><br /><br /><h3><span style="font-size: large;">8.5 （防火牆）隔離你的程式，避免錯誤造成損毀<br />Barricade Your Program to Contain the Damage Caused by Errors</span></h3><br />概念：船構造的隔艙，讓船在進水時，可以隔離充滿水的船艙。<br /><br /><b>在輸入時間，將輸入資料轉換為正確的型別</b><br />建立「防火牆」讓資料轉態、檢查資料格式、檢查資料內容，直到正確，才進入運算。<br /><br /><h4>防火牆與判斷提示的關係<br />Relationship between Barricades and Assertions</h4>防火牆外的常式，使用錯誤處理（各種適合的方法），假設資料都不安全<br />防火牆內的常式，使用assert()。<br />防火牆內偵測到錯誤的資料，代表程式有錯，而不是資料有錯。<br /><br /><br /><h3><span style="font-size: large;">8.6 除錯輔助工具<br />Debugging Aids</span></h3><br /><h4>不要在debug版程式直接套用release版程式的規範<br />Don’t Automatically Apply Production Constraints to the Development Version</h4><table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;" x:str=""> <colgroup><col span="3"></col> </colgroup><tbody><tr>  <td style="height: 16.5pt; width: 54pt;" width="72"></td>  <td>release</td>  <td>debug</td> </tr><tr>  <td>速度</td>  <td>快</td>  <td>不一定要快</td> </tr><tr>  <td>資源</td>  <td>愈少愈好</td>  <td>盡量使用</td> </tr><tr>  <td>操作的安全性</td>  <td>必須要安全</td>  <td>可使用不安全的操作</td> </tr></tbody></table>最優先的考量：保持開發過程的流暢<br /><br /><h4>儘早採用除錯輔助工具<br />Introduce Debugging Aids Early</h4>遇到了十次相同的問題，第十一次之後受不了了，寫了一個除錯輔助工具之後，再也不會遇到這個問題，心情愉快、工作順利，程式碼都乖乖的呢。<br />為了節省時間，保持開發過程流暢，不影響心情。請儘早使用。<br /><br />通常會有三種情況，會取得除錯輔助工具<br /><ol><li>遇到了好幾次相同的問題。</li><li>初次寫除錯輔助程式</li><li>使用之前專案的除錯輔助工具</li></ol><h4>使用自殺式程式設計（原意：攻擊式程式設計）<br />Use Offensive Programming</h4>應該以這麼一種方式來處理異常情況：在開發階段將它突顯出來，在產品代碼時它可以自我修復。←就是Offensive Programming<br /><br />自殺式程式設計方法有幾個原則（看完就知道為什麼我這樣翻譯了）<br /><ul><li>確定以assert()中止程式</li><li>完全填滿記憶體，偵測記憶體配置問題</li><li>完全填滿分配的檔案，偵測出檔案格式的錯誤</li><li>確定每個「case陳述式的default」或「else子句」的程式碼能產生錯誤（ex: 中止程式）或無法被忽略。</li><li>刪除物件前，填入垃圾值，確定它再也用不到。</li><li>設定程式將錯誤記錄檔以mail的方式寄給自己，以了解release後的軟體中發生的錯誤種類。</li></ul><br /><h4>計畫性移除錯輔助工具<br />Plan to Remove Debugging Aids</h4>為了大小和速度必須拆除鷹架（除錯輔助程式碼）<br /><br /><b>使用版本工具，並建立<a href="http://ant.apache.org/" target="_blank">ant</a>和<a href="http://gnuwin32.sourceforge.net/packages/make.htm" target="_blank">make</a>等工具</b><br />ant 是java使用的工具，make就是makefile的工具。<br /><br /><b>使用內嵌的前置處理器</b><br />技巧性的使用條件編譯，可以留下鷹架，讓它不會編譯進release版<br />使用前置處理器的code，讓#ifdef-#endif這樣的程式碼不會讓你的程式變醜醜的。 <br /><pre class="prettyprint"><code>#define DEBUG<br />...<br />#if define( DEBUG )<br />// debugging code<br />...<br />#endif</code></pre><pre class="prettyprint"><code>#define DEBUG<br />#if define( DEBUG )<br />#define DebugCode( code_fragment ) { code_fragment }<br />#else<br />#define DebugCode( code_fragment )<br />#endif<br />...<br />DebugCode(<br /><br />    statement 1;<br />    statement 2;<br />    statement 3;<br /><br />);<br />...</code></pre><b>撰寫自己的前置處理器</b><br />Java沒有，就自己寫一個吧！<br /><b>使用除錯虛設常式</b><br />虛設的意思就是只剩下殼而沒有內容的常式，原文用stubs（存根）這個字。<br />相較於前置處理器危險的做法，這種做法可以讓編譯器幫你檢查除錯輔助程式的錯誤，並且有和條件編譯有相同的效果。 <br /><pre class="prettyprint"><code>void DoSomething(SOME_TYPE *pointer)<br />{<br />    //check parameters passed in<br />    CheckPoint( pointer );<br />    ...<br />}</code></pre>debug版的程式碼，必須全面性的檢查錯誤，秏時但有效 <br /><pre class="prettyprint"><code>void CheckPinter( void *pointer )<br />{<br />    // perform check 1 -- maybe check that it's not NULL<br />...<br />}</code></pre>release版的程式碼，必須追求效率，可以用下面的程式碼取代上面的程式碼 <br /><pre class="prettyprint"><code>void CheckPinter( void *pointer )<br />{<br />    // no code<br />}<br /></code></pre><br /><br /><h3><span style="font-size: large;">8.7 決定實際實執行所採用的防禦性程式設計程式碼<br />Determining How Much Defensive Programming to Leave in Production Code</span></h3>防禦性程式設計的茅盾之處，就是我們希望在開發時突顯錯誤，在發行時隱藏錯誤。<br />所以，發行之後，還是要保持一些程式碼來對付錯誤，又要保持效率，當中的取捨就是本節的重點。<br /><br /><b>保留檢查重要錯誤的程式碼</b><br /><b>移除檢查次要錯誤的程式碼</b><br /><b>移除導致當機的程式碼</b>（考慮是否影響生命）<br /><b>保留有助於程式妥善當機的程式碼</b><br /><b>記錄錯誤提供給技術人員</b><br /><b>確保保留的錯誤訊息是友善的</b><br /><br /><br /><h3><span style="font-size: large;">8.8 防禦性程式設計的防禦狀態<br />Being Defensive About Defensive Programming</span></h3><div>防禦性程式不可能沒有缺失，請考慮採取的防禦姿態，再安排設計的優先順序。</div>
