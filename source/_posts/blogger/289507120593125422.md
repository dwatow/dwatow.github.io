---
title: 有參數的衍生類別建構子，呼叫有參數的基礎類別建構子
date: 2015-05-07T14:57:00.001+08:00
tags: 
- C_and_Cpp

categories:
- 舊部落格移植文章
---

# 有參數的衍生類別建構子，呼叫有參數的基礎類別建構子

原文連結: https://darkblack01.blogspot.com/2015/05/blog-post.html
移植時的最後更新日期: 2015-12-23T14:16:57.650+08:00

這次要講的是「有參數的衍生類別建構子，呼叫有參數的基礎類別建構子」(有點長)<br /><br />先假設一個繼承的關係如下 <br /><pre class="prettyprint"><code>class Base<br />{<br />protected:<br />    const string m_IniFilePathName;<br />public:<br />    Base(const string&amp; iniFilePathName): m_IniFilePathName(iniFilePathName){}<br />private:<br />    Base(){};<br />};<br /><br />class Derivative : public Base<br />{<br />public:<br />    Derivative(const string&amp; iniFilePathName);<br />};</code></pre>在這個時候，Derivative 的建構式要怎麼設計呢？ <br />下列來介紹幾種常見卻不可行的做法 <br /><pre class="prettyprint"><code>Derivative::Derivative(const string&amp; iniFilePathName): m_IniFilePathName(iniFilePathName){}</code></pre>這樣會因為「m_IniFilePathName沒有在Derivative 宣告」而失敗。 <br /><pre class="prettyprint"><code>Derivative::Derivative(const string&amp; iniFilePathName)<br />{<br />    m_IniFilePathName = iniFilePathName;<br />}</code></pre>這樣會除了上述的問題之讓，還會因為m_IniFilePathName 是const而「無法進行賦值，只能初始化」而失敗。<br /><br />而且這樣設計還有一個重點，就是無法不初始化基礎類別(Base)。<br />因為Derivative的建構子會預設使用Base的無參數建構子。<br />但是在此Base的無參數建構子設成private，所以就算Derivative放棄用參數建構也是不行。<br /><br />真正要解決這件事怎辦？ <pre class="prettyprint"><code>Derivative::Derivative(const string& iniFilePathName): Base(iniFilePathName){}</code></pre>只要這麼做，就可以使用有參數的基礎類別囉！基礎類別建構子中初始化過的變數，也就不用再貼過來衍生類別的建構子囉。
