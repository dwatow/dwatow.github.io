---
title: 重構CH1//重構第二步
date: 2012-12-01T11:05:00.000+08:00
tags: 
- 重構

categories:
- 舊部落格移植文章
---

# 重構CH1//重構第二步

原文連結: https://darkblack01.blogspot.com/2012/12/ch1.html
移植時的最後更新日期: 2012-12-01T11:11:04.583+08:00

<h3>提煉「常客積點計算」程式碼</h3>承第一步的最後一段程式<br />在statement()裡面的這一段<br /><span style="color: #3d85c6;">這一段積點計算程式，應該放在Rental class身上，運用<b><span style="font-size: large;">Extract Method</span></b></span><br /><a name='more'></a><br /><pre class="prettyprint"><code>inline std::string Customer::statement()<br />{<br />    double totalAmount = 0;       //消費總金額<br />    int frequentReterPoints = 0;  //常客積點<br />    std::vector::const_iterator rentals = _rentals.begin();<br />    std::string result = "Rental Record for " + getName() + "\n";<br /><br />    while(retals.hasMoreElements())<br />    {<br />        rentals++;<br />        Rental each = *rentals;    //取得一筆租借記錄<br />//----------------------------------------------------------------------------<br />        //add frequent renter points(累加 常客積點)<br />        frequentReterPoints++;<br />        //add bonus for a two day new release rental<br />        if ((each.getMovie().getPriceCode() == Movie.NEW.RELEASE) &amp;&amp; each.getDayRented() &gt; 1))<br />            frequentReterPoints++;<br />//----------------------------------------------------------------------------<br />        //show figures for this rental (顯示這筆租借資料）<br />        result += "\t" + each.getMovie().getTitle() + "\t" + std::string.valueOf(each.getCharge()) + "\n";<br />        totalAmount += each.getCharge();<br />    }<br /><br />    //add footer lines（結尾列印）<br />    result += "Amount owed is " + std::string.valueOf(totalAmount) + "\n";<br />    rental += "You earned " + std::string.valueOf(frequentReterPoints) + " frequent renter points";<br /><br />    return result;<br />}</code></pre><span style="color: #3d85c6;">再一次尋找區域變數。</span><br /><br />再這找到了each和fequentRenterPoints<br />使用前，有初值，提出來的函式不需傳入該值<br />只要做appending assignment, operator +=的動作<br /><pre class="prettyprint"><code>inline std::string Customer::statement()<br />{<br />    double totalAmount = 0;       //消費總金額<br />    int frequentReterPoints = 0;  //常客積點<br />    std::vector<rental>::const_iterator rentals = _rentals.begin();<br />    std::string result = "Rental Record for " + getName() + "\n";<br /><br />    while(retals.hasMoreElements())<br />    {<br />        rentals++;<br />        Rental each = *rentals;    //取得一筆租借記錄<br />//----------------------------------------------------------------------------<br />        frequentReterPoints += each.getFrequentRenterPoints();<br />//----------------------------------------------------------------------------<br />        //show figures for this rental (顯示這筆租借資料）<br />        result += "\t" + each.getMovie().getTitle() + "\t" + std::string.valueOf(each.getCharge()) + "\n";<br />        totalAmount += each.getCharge();<br />    }<br /><br />    //add footer lines（結尾列印）<br />    result += "Amount owed is " + std::string.valueOf(totalAmount) + "\n";<br />    rental += "You earned " + std::string.valueOf(frequentReterPoints) + " frequent renter points";<br /><br />    return result;<br />}</rental></code></pre>提煉出來...變成<br /><pre class="prettyprint"><code>inline int Rental::getFrequentRenterPoints()<br />{<br />    if ((getMovie().getPriceCode() == Movie.NEW.RELEASE) &amp;&amp; getDayRented() &gt; 1))<br />        return 2;<br />    else <br />        return 1;<br />}</code></pre><br /><h3>去除暫時變數</h3><br /><span style="color: #3d85c6;">運用<span style="font-size: large;"><b>Replace Temp with Query</b></span></span><br />用query method來取代totalAmount和frequentRenterPoint這兩個暫時的變數<br /><span style="color: #3d85c6;">query method可以促進較乾淨的設計。和</span><br /><pre class="prettyprint"><code>inline std::string Customer::statement()<br />{<br />//    double totalAmount = 0;       //消費總金額<br />    int frequentReterPoints = 0;  //常客積點<br />    std::vector&lt;rental&gt;::const_iterator rentals = _rentals.begin();<br />    std::string result = "Rental Record for " + getName() + "\n";<br /><br />    while(retals.hasMoreElements())<br />    {<br />        rentals++;<br />        Rental each = *rentals;    //取得一筆租借記錄<br />        frequentReterPoints += each.getFrequentRenterPoints();<br /><br />        //show figures for this rental (顯示這筆租借資料）<br />        result += "\t" + each.getMovie().getTitle() + "\t" + std::string.valueOf(each.getCharge()) + "\n";<br />//        totalAmount += each.getCharge();<br />    }<br />    //add footer lines（結尾列印）<br />    result += "Amount owed is " + std::string.valueOf(getTotalCharge()) + "\n";<br />                                   //totalsAmount 改成 getTotalCharge()<br />    rental += "You earned " + std::string.valueOf(frequentReterPoints) + " frequent renter points";<br /><br />    return result;<br />}</code></pre>這就是所謂的query method<br /><span style="color: #0b5394;">把totalAmount整個搬走，包含回圈內的變動。 </span><br /><pre class="prettyprint"><code>inline double Customer::getTotalCharge()<br />{<br />    double result = 0;<br />    std::vector&lt;rental&gt;::const_iterator rentals = _rentals.begin();<br />    while (rentals.hasMoreElements())<br />    {<br />        rentals++;<br />        Rental each = *rentals;    //取得一筆租借記錄<br />        result += each.getCharge();<br />    }</code></pre><pre class="prettyprint"><code>    return result;<br />}</code></pre>測試完，沒問題之後，再接著處理frequentReterPoints  <br />statement()改成這樣<br /><pre class="prettyprint"><code>inline std::string Customer::statement()<br />{<br />//    double totalAmount = 0;       //消費總金額<br />//    int frequentReterPoints = 0;  //常客積點<br />    std::vector<rental>::const_iterator rentals = _rentals.begin();<br />    std::string result = "Rental Record for " + getName() + "\n";<br /><br />    while(retals.hasMoreElements())<br />    {<br />        rentals++;<br />        Rental each = *rentals;    //取得一筆租借記錄<br />//        frequentReterPoints += each.getFrequentRenterPoints();<br /><br />        //show figures for this rental (顯示這筆租借資料）<br />        result += "\t" + each.getMovie().getTitle() + "\t" + std::string.valueOf(each.getCharge()) + "\n";<br />//        totalAmount += each.getCharge();<br />    }<br />    //add footer lines（結尾列印）<br />    result += "Amount owed is " + std::string.valueOf(getTotalCharge()) + "\n";<br />    rental += "You earned " + std::string.valueOf(getTotalFrequentReterPoints()) + " frequent renter points";<br /><br />    return result;<br />}</rental></code></pre>再把frequentReterPoints整個搬走<br /><pre class="prettyprint"><code>inline int getTotalFrequentReterPoints()<br />{<br />    int result = 0;<br />    std::vector<rental>::const_iterator rentals = _rentals.begin();<br />    while (rentals.hasMoreElements())<br />    {<br />        rentals++;<br />        Rental each = *rentals;<br />        result += each.getFrequentRenterPoints();<br />    }<br />    return result;<br />}</rental></code></pre>這樣就完成「重構」這個動作了。<br />但是，這樣子的重構，讓程式碼變多，而且運算while的次數也變多了<br />這樣重構之後的效率不就變差了？<br /><br /><span style="color: #cc0000;">重構不需要擔心效率和程式碼多寡的問題，最佳化時，才需要擔心這一個部份。</span><br /><br />現在，Customer內的任何程式碼都可以取用這些query method了。<br />如果沒有這些query methods，其它函式就必須了解Rental class，並自行建立回圈。（違反封裝）<br /><br />接下來就可以放心的添加新功能了。
