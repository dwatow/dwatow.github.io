---
title: CP VC6//虛擬函數+動態連結的另類實作
date: 2012-09-13T11:37:00.001+08:00
tags: 
- 抱怨VC6

categories:
- 舊部落格移植文章
---

# CP VC6//虛擬函數+動態連結的另類實作

原文連結: https://darkblack01.blogspot.com/2012/09/cp-vc6_13.html
移植時的最後更新日期: 2013-12-13T09:23:02.817+08:00

原本實作了出了問題，後來朋友用g++過了，<a href="http://darkblack01.blogspot.tw/2012/09/blog-post.html">程式碼</a>也給我了。<br />看一看，這做法，我印象中做過呀！？？<br />貼到VC6，結果ERROR C2555<br /><br />心想：這就是傳說中的「微軟不符合標準C++嗎？」<br />Google了一下，微軟自己還在文件說明中指出，這是產品的問題，更好笑的是，文件的Title寫：「<a href="http://support.microsoft.com/kb/240862">修正: C2555 共的傳回型別具有虛擬函式</a>」。<br /><br />跟本沒有修正，只說「.Net就修正了」<br />（意思是你愛用VC6是你家的事，不換.Net活該？= =）<br /><br /><a name='more'></a>不過，我後來硬幹了一個做法，似乎可行！（似乎啦^^"）<br /><pre class="prettyprint"><code>#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />class A<br />{<br />public:<br />    virtual A* fun1() = 0;<br />    virtual A* fun2() = 0;<br />};<br /><br />class B : public A<br />{<br />public:<br />    A* fun1() { cout &lt;&lt; "B::fun1()" &lt;&lt;endl; return dynamic_cast&lt;A*&gt;(this);}<br />    A* fun2() { cout &lt;&lt; "B::fun2()" &lt;&lt;endl; return dynamic_cast&lt;A*&gt;(this);}<br />};<br /><br />class C : public A<br />{<br />public:<br />    A* fun1() { cout &lt;&lt; "C::fun1()" &lt;&lt;endl; return dynamic_cast&lt;A*&gt;(this);}<br />    A* fun2() { cout &lt;&lt; "C::fun2()" &lt;&lt;endl; return dynamic_cast&lt;A*&gt;(this);}<br />};<br /><br />int main()<br />{<br />    B b1;<br />    C c1;<br /><br />    A* a = &b1;<br />    a-&gt;fun1()-&gt;fun2();<br /><br />    a = &c1;<br />    a-&gt;fun1()-&gt;fun2();<br />}</code></pre>程式結果：<br /><br />B::fun1()<br />B::fun2()<br />C::fun1()<br />C::fun2()<br />Press any key to continue<br /><br /><br />但是，和別人討論完，發現....<br />下面這樣做也行。<br /><br /><pre class="prettyprint"><code>#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />class A<br />{<br />public:<br />    virtual A*fun1() = 0;<br />    virtual A*fun2() = 0;<br />};<br /><br />class B : public A<br />{<br />public:<br />    A* fun1() { cout &lt;&lt; "B::fun1()" &lt;&lt;endl; return this; }<br />    A* fun2() { cout &lt;&lt; "B::fun2()" &lt;&lt;endl; return this; }<br />};<br /><br />class C : public A<br />{<br />public:<br />    A* fun1() { cout &lt;&lt; "C::fun1()" &lt;&lt;endl; return this; }<br />    A* fun2() { cout &lt;&lt; "C::fun2()" &lt;&lt;endl; return this; }<br />};<br /><br />int main()<br />{<br />    B b1;<br />    C c1;<br /><br />    A* a = &b1;<br />    a-&gt;fun1()-&gt;fun2();<br /><br />    a = &c1;<br />    a-&gt;fun1()-&gt;fun2();<br />}</code></pre><br />程式結果：<br /><br />B::fun1()<br />B::fun2()<br />C::fun1()<br />C::fun2()<br />Press any key to continue<br /><br /><br />
