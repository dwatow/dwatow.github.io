---
title: "function template裡使用vector和iterator"
date: 2014-03-06T11:45:00.002+08:00
tags: 
- "C_and_Cpp"
- "抱怨VC6"
categories:
- 舊部落格移植文章
---

# function template裡使用vector和iterator

原文連結: https://darkblack01.blogspot.com/2014/03/function-templatevector.html
移植時的最後更新日期: 2015-12-23T14:16:57.740+08:00

一開始的程式碼是這樣<br /><pre class="prettyprint"><code>void Add(std::vector&lt;double&gt; _V)<br />{<br />    for (std::vector&lt;double&gt;::iterator _I = _V.begin(); _I != _V.end(); ++_I)<br />        add(*_I);<br />}</code></pre><pre class="prettyprint"><code>void Add(std::vector&lt;CString&gt; _V)<br />{<br />    for (std::vector&lt;CString&gt;::iterator _I = _V.begin(); _I != _V.end(); ++_I)<br />        add(*_I);<br />}</code></pre>就想使用template將它們兩個合併成一組程式碼<br /><pre class="prettyprint"><code>template&lt;class T&gt; <br />void Add(std::vector&lt;T&gt; _V)<br />{<br />    for (std::vector&lt;T&gt;::iterator _I = _V.begin(); _I != _V.end(); ++_I)<br />        add(*_I);<br />}</code></pre>如果你也覺得這樣的程式碼沒問題，就值得繼續往下看，因為他complier一萬年也不會過！！<br /><br /><br />在Google「function template vector」之後，終於有<a href="http://stackoverflow.com/questions/19094340/stdvector-as-a-template-function-argument" target="_blank">結果</a>了。[1]<br /><pre class="prettyprint"><code>template&lt;typename T, typename A&gt;<br />void some_func( std::vector&lt;T,A&gt; const&amp; vec ) {}</code></pre>但是還是不行！怎麼會這樣？！<br />這時，就讓我想起一句話<br /><br /><b><span style="font-size: large;">「M$不符合標準，因為他當自己就是標準」</span></b><br /><br />所以，我就將程式碼改成這樣(測試平台: VC6)<br /><pre class="prettyprint"><code>template&lt;class T&gt; <br />void Add(std::vector&lt;T,std::allocator&lt;T&gt; &gt; const &amp; _V)<br />{<br />    for (std::vector&lt;T&gt;::iterator _I = _V.begin(); _I != _V.end(); ++_I)<br />        add(*_I);<br />}</code></pre>就可以了！(哭哭)<br /><br />但是，標準要怎麼寫呢？<br />我就使用MiniGW&nbsp;+ Sublime text 2來測試一下<br />果然VC6的寫法不適合，那要怎麼改呢？<br /><br />再Google「function template vector iterator」了一陣子，終於有<a href="http://stackoverflow.com/questions/5192874/question-about-vector-iterator-in-template-functions" target="_blank">結果</a>了。[2]<br /><br />改成下面這樣，就可以了！<br /><pre class="prettyprint"><code>#include &lt;vector&gt;<br />#include &lt;iterator&gt;<br />#include &lt;string&gt;<br />#include &lt;iostream&gt;<br /><br />class Display<br />{<br />public:<br />    template &lt; typename T, typename A &gt;<br />    void Show( std::vector&lt;T,A&gt; const&amp; vec )<br />    { <br />        typename std::vector&lt;T&gt;::const_iterator it;<br />        for (it = vec.begin(); it != vec.end(); ++it)<br />            std::cout &lt;&lt; *it &lt;&lt; std::endl;<br />    }<br />};<br /><br />int main()<br />{<br />    std::vector&lt;double&gt; vD;<br />    vD.push_back(2.4);<br />    vD.push_back(2.1);<br />    vD.push_back(2.2);<br />    vD.push_back(2.3);<br /><br />    std::vector&lt;std::string&gt; vS;<br />    vS.push_back("這是");<br />    vS.push_back("這是..");<br />    vS.push_back("這是...");<br />    vS.push_back("這是....");<br />    vS.push_back("...");<br /><br /><br />    Display A;<br />    A.Show(vD);<br /><br />    Display B;<br />    B.Show(vS);<br />}</code></pre>程式執行結果<br /><pre class="prettyprint"><code>2.4<br />2.1<br />2.2<br />2.3<br />這是<br />這是..<br />這是...<br />這是....<br />...</code></pre><br />最後的最後一件事提醒，<span style="color: #cc0000;">function template的定義(不是宣告唷，是定義)請寫在.h檔[3]<strike>或者使用inline</strike></span>。<br /><br />參考資料：<br />[1] <a href="http://stackoverflow.com/questions/19094340/stdvector-as-a-template-function-argument" target="_blank">c++ - std::vector as a template function argument - Stack Overflow</a><br />[2] <a href="http://stackoverflow.com/questions/5192874/question-about-vector-iterator-in-template-functions" target="_blank">c++ - Question about vector iterator in template functions - Stack Overflow</a><br />[3] <a href="http://social.msdn.microsoft.com/Forums/vstudio/en-US/629b6804-a8b6-4cad-beb2-5272e538a9c4/fatal-error-lnk1120-2-unresolved-externals" target="_blank">fatal error LNK1120: 2 unresolved externals</a>
