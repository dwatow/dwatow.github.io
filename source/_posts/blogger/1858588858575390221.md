---
title: Sort of C++
date: 2015-05-08T13:34:00.001+08:00
tags: 
- C_and_Cpp

categories:
- 舊部落格移植文章
---

# Sort of C++

原文連結: https://darkblack01.blogspot.com/2015/05/sort-of-c.html
移植時的最後更新日期: 2015-12-23T14:16:57.617+08:00

C++的容器，是C++厲害的地方。<br />C++的容器，可以使用泛型演算法。<br />C++的容器....這是不是寫詩呀！&gt;&lt;<br /><br />C++的容器，放入指標，如何依指標指向的物件「排序」？<br /><pre class="prettyprint"><code>class aObject<br />{<br />public:<br />    int GetIndex() const{ return m_Index; }<br />    int GetScore() const{ return m_Score; }<br />    int m_Index;  //索引<br />    int m_Score;  //得分<br />};<br /></code></pre><pre class="prettyprint"><code>//main<br />list&lt;aObject*&gt; obj_list;<br />//中間填入東西<br />obj_list.sort();</code></pre>在這種情況，預設的sort是會依照指標的位址排序<br /><br />這時就要使用自訂義排序方式。<br />不過書上教你的自訂義排序方式都不是教你排指標。<br />不過！這還是辦得到的唷！<br /><br />宣告式如下，不過如果沒有放在class裡，就不用static<br /><pre class="prettyprint"><code>static bool SortByIndex( aObject* const m_aObject0, aObject* const m_aObject1 );<br />static bool SortByScore( aObject* const m_aObject0, aObject* const m_aObject1 );</code></pre>實作要這樣 <pre class="prettyprint"><code>bool SortByIndex( aObject* const m_aObject0, aObject* const m_aObject1 )<br />{<br />    if (m_aObject0->GetIndex() >= m_aObject1->GetIndex())<br />    {<br />        return true;<br />    }<br />    else<br />    {<br />        return false;<br />    }<br />}<br /><br />bool SortByScore( aObject* const m_aObject0, aObject* const m_aObject1 )<br />{<br />    if (m_aObject0->GetScore() >= m_aObject1->GetScore())<br />    {<br />        return true;<br />    }<br />    else<br />    {<br />        return false;<br />    }<br />}</code></pre>寫好這個之後，就可以囉 <pre class="prettyprint"><code>//main<br />list&lt;aObject*&gt; obj_list;<br />//中間填入東西<br />obj_list.sort(SortByIndex);<br />obj_list.sort(SortByScore);</code></pre>在這種情況，預設的sort是會依照指標的位址排序<br /><br />
